<html>

<head>
</head>

<body>
<h1><a name="IO">I/O</a></h1>

<p><span>Creating
a good input/output (I/O) system is one of the more difficult tasks for a
language designer. This is evidenced by the number of different approaches. </span></p>

<p><span>The
challenge seems to be in covering all possibilities. Not only are there
different sources and sinks of I/O that you want to communicate with (files,
the console, network connections, etc.), but you need to talk to them in a wide
variety of ways (sequential, random-access, buffered, binary, character, by
lines, by words, etc.). The Java library designers attacked this problem by
creating lots of classes. In fact, there are so many classes for Java's I/O
system that it can be intimidating at first (ironically, the Java I/O design
actually prevents an explosion of classes). There was also a significant change
in the I/O library after Java i.o, when the original byte-oriented library was
supplemented with <b>char</b>-oriented, Unicode-based I/O classes. The <b>nio </b>classes
(for &quot;new I/O,&quot; a name we'll still be using years from now even
though they were introduced in JDK 1.4 and so are already &quot;old&quot;) were
added for improved performance and functionality. As a result, there are a fair
number of classes to learn before you understand enough of Java's I/O picture
that you can use it properly. In addition, it's rather important to understand
the evolution of the I/O library, even if your first reaction is &quot;Don't
bother me with history, just show me how to use it!&quot; The problem is that
without the historical perspective, you will rapidly become confused with some
of the classes and when you should and shouldn't use them. This chapter will
give you an introduction to the variety of I/O classes in the standard Java
library and how to use them. </span></p>

<h2><a name="TheFileClass">The File class</a></h2>

<p><span>Before
getting into the classes that actually read and write data to streams, we'll
look at a library utility that assists you with file directory issues. The <b>File
</b>class has a deceiving name; you might think it refers to a file, but it
doesn't. In fact, &quot;FilePath&quot; would have been a better name for the
class. It can represent either the <i>name </i>of a particular file or the <i>names
</i>of a set of files in a directory. If it's a set of files, you can ask for
that set using the <b>list( ) </b>method, which returns an array of <b>String</b>.
It makes sense to return an array rather than one of the flexible container
classes, because the number of elements is fixed, and if you want a different
directory listing, you just create a different <b>File </b>object. This section
shows an example of the use of this class, including the associated <b>FilenameFilter
</b>interface. </span></p>

<p><span>A directory lister </span></p>

<p><span>Suppose
you'd like to see a directory listing. The <b>File </b>object can be used in
two ways. If you call <b>list( ) </b>with no arguments, you'll get the full
list that the <b>File </b>object contains. However, if you want a restricted
list for example, if you want all of the files with an extension of .Javathen
you use a &quot;directory filter,&quot; which is a class that tells how to
select the <b>File </b>objects for display. Here's the example. Note that the
result has been effortlessly sorted (alphabetically) using the <b>java.util.Arrays.sort(
) </b>method and the <b>String.CASE_INSENSITIVE_ORDER Comparator: </b></span></p>

<p><span>//: io/DirList.java </span></p>

<p><span>// Display a directory listing using regular
expressions. </span></p>

<p><span>// {Args: &quot;D.*\.java&quot;} </span></p>

<p><span>import java.util.regex.*; </span></p>

<p><span>import java.io.*; </span></p>

<p><span>import java.util.*; </span></p>

<p><span>public class DirList { </span></p>

<p><span>public static void main(String[] args) { </span></p>

<p><span>File path = new File(&quot;.&quot;); </span></p>

<p><span>String[] list; </span></p>

<p><span>if(args.length == 0) </span></p>

<p><span>list = path.list(); </span></p>

<p><span>else </span></p>

<p><span>list = path.list(new DirFilter(args[0])); </span></p>

<p><span>Arrays.sort(list, String.CASE_INSENSITIVE_ORDER); </span></p>

<p><span>for(String dirItem : list) </span></p>

<p><span>System.out.println(dirItem); </span></p>

<p><span>} </span></p>

<p><span>} </span></p>

<p><span>class DirFilter implements FilenameFilter { </span></p>

<p><span>private Pattern pattern; </span></p>

<p><span>public DirFilter(String regex) { </span></p>

<p><span>pattern = Pattern.compile(regex); </span></p>

<p><span>} </span></p>

<p><span>public boolean accept(File dir, String name) { </span></p>

<p><span>return pattern.matcher(name).matches(); </span></p>

<p><span>} </span></p>

<p><span>} /* Output: </span></p>

<p><span>DirectoryDemo.java </span></p>

<p><span>DirList.java </span></p>

<p><span>DirList2.java </span></p>

<p><span>DirList3.java </span></p>

<p><span>*///:~ </span></p>

<p><span>The
<b>DirFilter </b>class implements the interface <b>FilenameFilter</b>. Notice
how simple the <b>FilenameFilter </b>interface is: </span></p>

<p><span>public interface FilenameFilter { </span></p>

<p><span>boolean accept(File dir, String name); </span></p>

<p><span>} </span></p>

<p><b><span>DirFilter's
</span></b><span>sole
reason for existence is to provide the <b>accept( ) </b>method to the <b>list(
) </b>method so that <b>list( ) </b>can &quot;call back&quot; <b>accept( ) </b>to
determine which file names should be included in the list. Thus, this structure
is often referred to as a <i>callback</i>. More specifically, this is an
example of the <i>Strategy </i>design pattern, because <b>list( ) </b>implements
basic functionality, and you provide the Strategy in the form of a <b>FilenameFilter
</b>in order to complete the algorithm necessary for <b>list( ) </b>to provide
its service. Because <b>list( ) </b>takes a <b>FilenameFilter </b>object as its
argument, it means that you can pass an object of any class that implements <b>FilenameFilter
</b>to choose (even at run time) how the <b>list( ) </b>method will behave. The
purpose of a Strategy is to provide flexibility in the behavior of code. </span></p>

<p><span>The
<b>accept( ) </b>method must accept a <b>File </b>object representing the
directory that a particular file is found in, and a <b>String </b>containing
the name of that file. Remember that the <b>list( ) </b>method is calling <b>accept(
) </b>for each of the file names in the directory object to see which one
should be included; this is indicated by the <b>boolean </b>result returned by <b>accept(
)</b>. </span></p>

<p><b><span>accept(
) </span></b><span>uses a
regular expression <b>matcher </b>object to see if the regular expression <b>regex
</b>matches the name of the file. Using <b>accept( )</b>, the <b>list( ) </b>method
returns an array. </span></p>

<p><i><span>648 Thinking in Java Bruce Eckel </span></i></p>

<p><span>Anonymous inner classes </span></p>

<p><span>This example is ideal for rewriting using an anonymous inner
class (described in <i>Inner Classes)</i>. As a first cut, a method <b>filter(
) </b>is created that returns a reference to a <b>FilenameFilter: </b></span></p>

<p><span>//: io/DirList2.java </span></p>

<p><span>// Uses anonymous inner classes. </span></p>

<p><span>// {Args: &quot;D.*\.java&quot;} </span></p>

<p><span>import java.util.regex.*; </span></p>

<p><span>import java.io.*; </span></p>

<p><span>import java.util.*; </span></p>

<p><span>public class DirList2 { </span></p>

<p><span>public static FilenameFilter
filter(final String regex) { </span></p>

<p><span>// Creation of anonymous inner
class: </span></p>

<p><span>return new FilenameFilter() { </span></p>

<p><span>private Pattern pattern =
Pattern.compile(regex); </span></p>

<p><span>public boolean accept(File dir,
String name) { </span></p>

<p><span>return
pattern.matcher(name).matches(); </span></p>

<p><span>} </span></p>

<p><span>}; // End of anonymous inner class </span></p>

<p><span>} </span></p>

<p><span>public static void main(String[]
args) { </span></p>

<p><span>File path = new
File(&quot;.&quot;); </span></p>

<p><span>String[] list; </span></p>

<p><span>if(args.length == 0) </span></p>

<p><span>list = path.list(); </span></p>

<p><span>else </span></p>

<p><span>list = path.list(filter(args[0])); </span></p>

<p><span>Arrays.sort(list,
String.CASE_INSENSITIVE_ORDER); </span></p>

<p><span>for(String dirItem : list) </span></p>

<p><span>System.out.println(dirItem); </span></p>

<p><span>} </span></p>

<p><span>} /* Output: </span></p>

<p><span>DirectoryDemo.java </span></p>

<p><span>DirList.java </span></p>

<p><span>DirList2.java </span></p>

<p><span>DirList3.java </span></p>

<p><span>*///:~ </span></p>

<p><span>Note that the argument to <b>filter( ) </b>must be <b>final</b>.
This is required by the anonymous inner class so that it can use an object from
outside its scope. This design is an improvement because the <b>FilenameFilter </b>class
is now tightly bound to <b>DirList2</b>. However, you can take this approach
one step further and define the anonymous inner class as an argument to <b>list()</b>,
in which case it's even smaller: </span></p>

<p><span>//: io/DirList3.java </span></p>

<p><span>// Building the anonymous inner
class &quot;in-place.&quot; </span></p>

<p><span>// {Args: &quot;D.*\.java&quot;} </span></p>

<p><span>import java.util.regex.*; </span></p>

<p><span>import java.io.*; </span></p>

<p><span>import java.util.*; </span></p>

<p><span>public class DirList3 { </span></p>

<p><span>public static void main(final
String[] args) { </span></p>

<p><span>File path = new
File(&quot;.&quot;); </span></p>

<p><span>String[] list; </span></p>

<p><span>if(args.length == 0) </span></p>

<p><span>list = path.list(); </span></p>

<p><span>else </span></p>

<p><i><span>I/O 649 </span></i></p>

<p><span>list =
path.list(new FilenameFilter() { </span></p>

<p><span>private Pattern pattern = Pattern.compile(args[0]);
</span></p>

<p><span>public boolean accept(File dir,
String name) { </span></p>

<p><span>return
pattern.matcher(name).matches(); </span></p>

<p><span>} </span></p>

<p><span>}); </span></p>

<p><span>Arrays.sort(list,
String.CASE_INSENSITIVE_ORDER); </span></p>

<p><span>for(String dirItem : list) </span></p>

<p><span>System.out.println(dirItem); </span></p>

<p><span>} </span></p>

<p><span>} /* Output: </span></p>

<p><span>DirectoryDemo.java </span></p>

<p><span>DirList.java </span></p>

<p><span>DirList2.java </span></p>

<p><span>DirList3.java </span></p>

<p><span>*///:~ </span></p>

<p><span>The argument to <b>main( ) </b>is now <b>final</b>, since the
anonymous inner class uses <b>args[0] </b>directly. </span></p>

<p><span>This shows you how anonymous inner classes allow the creation
of specific, one-off classes to solve problems. One benefit of this approach is
that it keeps the code that solves a particular problem isolated in one spot.
On the other hand, it is not always as easy to read, so you must use it
judiciously. </span></p>

<p><b><span>Exercise 1: </span></b><span>(3) Modify <b>DirList.java </b>(or
one of its variants) so that the <b>FilenameFilter </b>opens and reads each
file (using the <b>net.mindview.util.TextFile </b>utility) and accepts the file
based on whether any of the trailing arguments on the command line exist in
that file. </span></p>

<p><b><span>Exercise 2: </span></b><span>(2) Create a class called <b>SortedDirList
</b>with a constructor that takes a <b>File </b>object and builds a sorted
directory list from the files at that <b>File</b>. Add to this class two
overloaded <b>list( ) </b>methods: the first produces the whole list, and the
second produces the subset of the list that matches its argument (which is a
regular expression). </span></p>

<p><b><span>Exercise 3: </span></b><span>(3) Modify <b>DirList.java </b>(or
one of its variants) so that it sums up the file sizes of the selected files. </span></p>

<p><span>Directory
utilities </span></p>

<p><span>A common task in programming is to perform operations on sets
of files, either in the local directory or by walking the entire directory
tree. It is useful to have a tool that will produce the set of files for you.
The following utility class produces either an array of <b>File </b>objects in
the local directory using the <b>local( ) </b>method, or a <b>List&lt;File</b>&gt;
of the entire directory tree starting at the given directory using <b>walk( ) </b>(<b>File
</b>objects are more useful than file names because <b>File </b>objects contain
more information). The files are chosen based on the regular expression that
you provide: </span></p>

<p><span>//:
net/mindview/util/Directory.java </span></p>

<p><span>// Produce a sequence of File
objects that match a </span></p>

<p><span>// regular expression in either a
local directory, </span></p>

<p><span>// or by walking a directory tree. </span></p>

<p><span>package net.mindview.util; </span></p>

<p><span>import java.util.regex.*; </span></p>

<p><span>import java.io.*; </span></p>

<p><span>import java.util.*; </span></p>

<p><span>public final class Directory { </span></p>

<p><span>public static File[] </span></p>

<p><i><span>650 Thinking in Java Bruce Eckel </span></i></p>

<p><span>local(File
dir, final String regex) { </span></p>

<p><span>return dir.listFiles(new
FilenameFilter() { </span></p>

<p><span>private Pattern pattern =
Pattern.compile(regex); </span></p>

<p><span>public boolean accept(File dir,
String name) { </span></p>

<p><span>return pattern.matcher( </span></p>

<p><span>new
File(name).getName()).matches(); </span></p>

<p><span>} </span></p>

<p><span>}); </span></p>

<p><span>} </span></p>

<p><span>public static File[] </span></p>

<p><span>local(String path, final String
regex) { // Overloaded </span></p>

<p><span>return local(new File(path),
regex); </span></p>

<p><span>} </span></p>

<p><span>// A two-tuple for returning a pair
of objects: </span></p>

<p><span>public static class TreeInfo
implements Iterable&lt;File&gt; { </span></p>

<p><span>public List&lt;File&gt; files = new
ArrayList&lt;File&gt;(); </span></p>

<p><span>public List&lt;File&gt; dirs = new
ArrayList&lt;File&gt;(); </span></p>

<p><span>// The default iterable element is
the file list: </span></p>

<p><span>public Iterator&lt;File&gt;
iterator() { </span></p>

<p><span>return files.iterator(); </span></p>

<p><span>} </span></p>

<p><span>void addAll(TreeInfo other) { </span></p>

<p><span>files.addAll(other.files); </span></p>

<p><span>dirs.addAll(other.dirs); </span></p>

<p><span>} </span></p>

<p><span>public String toString() { </span></p>

<p><span>return &quot;dirs: &quot; +
PPrint.pformat(dirs) + </span></p>

<p><span>&quot;\n\nfiles: &quot; +
PPrint.pformat(files); </span></p>

<p><span>} </span></p>

<p><span>} </span></p>

<p><span>public static TreeInfo </span></p>

<p><span>walk(String start, String regex) {
// Begin recursion </span></p>

<p><span>return recurseDirs(new File(start),
regex); </span></p>

<p><span>} </span></p>

<p><span>public static TreeInfo </span></p>

<p><span>walk(File start, String regex) { //
Overloaded </span></p>

<p><span>return recurseDirs(start, regex); </span></p>

<p><span>} </span></p>

<p><span>public static TreeInfo walk(File
start) { // Everything </span></p>

<p><span>return recurseDirs(start,
&quot;.*&quot;); </span></p>

<p><span>} </span></p>

<p><span>public static TreeInfo walk(String
start) { </span></p>

<p><span>return recurseDirs(new File(start),
&quot;.*&quot;); </span></p>

<p><span>} </span></p>

<p><span>static TreeInfo recurseDirs(File
startDir, String regex){ </span></p>

<p><span>TreeInfo result = new TreeInfo(); </span></p>

<p><span>for(File item :
startDir.listFiles()) { </span></p>

<p><span>if(item.isDirectory()) { </span></p>

<p><span>result.dirs.add(item); </span></p>

<p><span>result.addAll(recurseDirs(item,
regex)); </span></p>

<p><span>} else // Regular file </span></p>

<p><span>if(item.getName().matches(regex)) </span></p>

<p><span>result.files.add(item); </span></p>

<p><span>} </span></p>

<p><span>return result; </span></p>

<p><span>} </span></p>

<p><span>// Simple validation test: </span></p>

<p><span>public static void main(String[]
args) { </span></p>

<p><span>if(args.length == 0) </span></p>

<p><span>System.out.println(walk(&quot;.&quot;));
</span></p>

<p><span>else </span></p>

<p><span>for(String arg : args) </span></p>

<p><span>System.out.println(walk(arg)); </span></p>

<p><i><span>I/O 651 </span></i></p>

<p><span>} </span></p>

<p><span>} ///:~ </span></p>

<p><span>The <b>local( ) </b>method uses a variant of <b>File.list( ) </b>called
<b>listFiles( ) </b>that produces an array of <b>File</b>. You can see that it
also uses a <b>FilenameFilter</b>. If you need a <b>List </b>instead of an
array, you can convert the result yourself using <b>Arrays.asList( )</b>. </span></p>

<p><span>The <b>walk( ) </b>method converts the name of the starting
directory into a <b>File </b>object and calls <b>recurseDirs( )</b>, which
performs a recursive directory walk, collecting more information with each
recursion. To distinguish ordinary files from directories, the return value is effectively
a &quot;tuple&quot; of objectsa <b>List </b>holding ordinary files, and
another holding directories. The fields are intentionally made <b>public </b>here,
because the point of <b>Treelnfo </b>is simply to collect the objects
togetherif you were just returning a <b>List</b>, you wouldn't make it <b>private</b>,
so just because you are returning a pair of objects, it doesn't mean you need
to make them <b>private</b>. Note that <b>Treelnfo </b>implements <b>Iterable&lt;File&gt;</b>,
which produces the files, so that you have a &quot;default iteration&quot; over
the file list, whereas you can specify directories by saying &quot;<b>.dirs</b>&quot;.
</span></p>

<p><span>The <b>Treelnfo.toString( ) </b>method uses a &quot;pretty
printer&quot; class so that the output is easer to view. The default <b>toString(
) </b>methods for containers print all the elements for a container on a single
line. For large collections this can become difficult to read, so you may want
to use an alternate formatting. Here's a tool that adds newlines and indents
each element: </span></p>

<p><span>//: net/mindview/util/PPrint.java </span></p>

<p><span>// Pretty-printer for collections </span></p>

<p><span>package net.mindview.util; </span></p>

<p><span>import java.util.*; </span></p>

<p><span>public class PPrint { </span></p>

<p><span>public static String
pformat(Collection&lt;?&gt; c) { </span></p>

<p><span>if(c.size() == 0) return
&quot;[]&quot;; </span></p>

<p><span>StringBuilder result = new
StringBuilder(&quot;[&quot;); </span></p>

<p><span>for(Object elem : c) { </span></p>

<p><span>if(c.size() != 1) </span></p>

<p><span>result.append(&quot;\n &quot;); </span></p>

<p><span>result.append(elem); </span></p>

<p><span>} </span></p>

<p><span>if(c.size() != 1) </span></p>

<p><span>result.append(&quot;\n&quot;); </span></p>

<p><span>result.append(&quot;]&quot;); </span></p>

<p><span>return result.toString(); </span></p>

<p><span>} </span></p>

<p><span>public static void
pprint(Collection&lt;?&gt; c) { </span></p>

<p><span>System.out.println(pformat(c)); </span></p>

<p><span>} </span></p>

<p><span>public static void pprint(Object[]
c) { </span></p>

<p><span>System.out.println(pformat(Arrays.asList(c)));
</span></p>

<p><span>} </span></p>

<p><span>} ///:~ </span></p>

<p><span>The <b>pformat( ) </b>method produces a formatted <b>String </b>from
a <b>Collection</b>, and the <b>pprint( ) </b>method uses <b>pformat( ) </b>to
do its job. Note that the special cases of no elements and a single element are
handled differently. There's also a version of <b>pprint( ) </b>for arrays. </span></p>

<p><span>The <b>Directory </b>utility is placed in the <b>net.mindview.util
</b>package so that it is easily available. Here's a sample of how you can use
it: </span></p>

<p><span>//: io/DirectoryDemo.java </span></p>

<p><span>// Sample use of Directory
utilities. </span></p>

<p><span>import java.io.*; </span></p>

<p><i><span>652 Thinking in Java Bruce Eckel </span></i></p>

<p><span>import
net.mindview.util.*; </span></p>

<p><span>import static
net.mindview.util.Print.*; </span></p>

<p><span>public class DirectoryDemo { </span></p>

<p><span>public static void main(String[]
args) { </span></p>

<p><span>// All directories: </span></p>

<p><span>PPrint.pprint(Directory.walk(&quot;.&quot;).dirs);
</span></p>

<p><span>// All files beginning with </span><span></span><span>T</span><span>'</span><span> </span></p>

<p><span>for(File file : Directory.local(&quot;.&quot;,
&quot;T.*&quot;)) </span></p>

<p><span>print(file); </span></p>

<p><span>print(&quot;----------------------&quot;);
</span></p>

<p><span>// All Java files beginning with </span><span></span><span>T</span><span>'</span><span>: </span></p>

<p><span>for(File file :
Directory.walk(&quot;.&quot;, &quot;T.*\\.java&quot;)) </span></p>

<p><span>print(file); </span></p>

<p><span>print(&quot;======================&quot;);
</span></p>

<p><span>// Class files containing
&quot;Z&quot; or &quot;z&quot;: </span></p>

<p><span>for(File file :
Directory.walk(&quot;.&quot;,&quot;.*[Zz].*\\.class&quot;)) </span></p>

<p><span>print(file); </span></p>

<p><span>} </span></p>

<p><span>} /* Output: (Sample) </span></p>

<p><span>[.\xfiles] </span></p>

<p><span>.\TestEOF.class </span></p>

<p><span>.\TestEOF.java </span></p>

<p><span>.\TransferTo.class </span></p>

<p><span>.\TransferTo.java </span></p>

<p><span>---------------------- </span></p>

<p><span>.\TestEOF.java </span></p>

<p><span>.\TransferTo.java </span></p>

<p><span>.\xfiles\ThawAlien.java </span></p>

<p><span>====================== </span></p>

<p><span>.\FreezeAlien.class </span></p>

<p><span>.\GZIPcompress.class </span></p>

<p><span>.\ZipCompress.class </span></p>

<p><span>*///:~ </span></p>

<p><span>You may need to refresh your knowledge of regular expressions
from the <i>Strings </i>chapter in order to understand the second arguments in <b>local(
) </b>and <b>walk( )</b>. </span></p>

<p><span>We can take this a step further and create a tool that will
walk directories <i>and </i>process the files within them according to a <b>Strategy
</b>object (this is another example of the <i>Strategy </i>design pattern): </span></p>

<p><span>//:
net/mindview/util/ProcessFiles.java </span></p>

<p><span>package net.mindview.util; </span></p>

<p><span>import java.io.*; </span></p>

<p><span>public class ProcessFiles { </span></p>

<p><span>public interface Strategy { </span></p>

<p><span>void process(File file); </span></p>

<p><span>} </span></p>

<p><span>private Strategy strategy; </span></p>

<p><span>private String ext; </span></p>

<p><span>public ProcessFiles(Strategy strategy,
String ext) { </span></p>

<p><span>this.strategy = strategy; </span></p>

<p><span>this.ext = ext; </span></p>

<p><span>} </span></p>

<p><span>public void start(String[] args) { </span></p>

<p><span>try { </span></p>

<p><span>if(args.length == 0) </span></p>

<p><span>processDirectoryTree(new
File(&quot;.&quot;)); </span></p>

<p><span>else </span></p>

<p><span>for(String arg : args) { </span></p>

<p><i><span>I/O 653 </span></i></p>

<p><span>File
fileArg = new File(arg); </span></p>

<p><span>if(fileArg.isDirectory()) </span></p>

<p><span>processDirectoryTree(fileArg); </span></p>

<p><span>else { </span></p>

<p><span>// Allow user to leave off
extension: </span></p>

<p><span>if(!arg.endsWith(&quot;.&quot; +
ext)) </span></p>

<p><span>arg += &quot;.&quot; + ext; </span></p>

<p><span>strategy.process( </span></p>

<p><span>new File(arg).getCanonicalFile()); </span></p>

<p><span>} </span></p>

<p><span>} </span></p>

<p><span>} catch(IOException e) { </span></p>

<p><span>throw new RuntimeException(e); </span></p>

<p><span>} </span></p>

<p><span>} </span></p>

<p><span>public void </span></p>

<p><span>processDirectoryTree(File root)
throws IOException { </span></p>

<p><span>for(File file : Directory.walk( </span></p>

<p><span>root.getAbsolutePath(),
&quot;.*\\.&quot; + ext)) </span></p>

<p><span>strategy.process(file.getCanonicalFile());
</span></p>

<p><span>} </span></p>

<p><span>// Demonstration of how to use it: </span></p>

<p><span>public static void main(String[]
args) { </span></p>

<p><span>new ProcessFiles(new ProcessFiles.Strategy()
{ </span></p>

<p><span>public void process(File file) { </span></p>

<p><span>System.out.println(file); </span></p>

<p><span>} </span></p>

<p><span>}, &quot;java&quot;).start(args); </span></p>

<p><span>} </span></p>

<p><span>} /* (Execute to see output) *///:~
</span></p>

<p><span>The <b>Strategy </b>interface is nested within <b>ProcessFiles</b>,
so that if you want to implement it you must <b>implement ProcessFiles.Strategy</b>,
which provides more context for the reader. <b>ProcessFiles </b>does all the
work of finding the files that have a particular extension (the <b>ext </b>argument
to the constructor), and when it finds a matching file, it simply hands it to
the <b>Strategy </b>object (which is also an argument to the constructor). </span></p>

<p><span>If you don't give it any arguments, <b>ProcessFiles </b>assumes
that you want to traverse all the directories off of the current directory. You
can also specify a particular file, with or without the extension (it will add
the extension if necessary), or one or more directories. </span></p>

<p><span>In <b>main( ) </b>you see a basic example of how to use the
tool; it prints the names of all the Java source files according to the command
line that you provide. </span></p>

<p><b><span>Exercise 4: </span></b><span>(2) Use <b>Directory.walk( ) </b>to
sum the sizes of all files in a directory tree whose names match a particular
regular expression. </span></p>

<p><b><span>Exercise 5: </span></b><span>(1) Modify <b>ProcessFiles.java </b>so
that it matches a regular expression rather than a fixed extension. </span></p>

<p><span>Checking
for and creating directories </span></p>

<p><span>The <b>File </b>class is more than just a representation for
an existing file or directory. You can also use a <b>File </b>object to create
a new directory or an entire directory path if it doesn't exist. You can also
look at the characteristics of files (size, last modification date,
read/write), see whether a <b>File </b>object represents a file or a directory,
and delete a file. The following example shows some of the other methods
available with the <b>File </b>class (see the JDK documentation from <i>http://java.sun.com
</i>for the full set): </span></p>

<p><i><span>654 Thinking in Java Bruce Eckel </span></i></p>

<p><span>//:
io/MakeDirectories.java </span></p>

<p><span>// Demonstrates the use of the File
class to </span></p>

<p><span>// create directories and
manipulate files. </span></p>

<p><span>// {Args: MakeDirectoriesTest} </span></p>

<p><span>import java.io.*; </span></p>

<p><span>public class MakeDirectories { </span></p>

<p><span>private static void usage() { </span></p>

<p><span>System.err.println( </span></p>

<p><span>&quot;Usage:MakeDirectories path1
...\n&quot; + </span></p>

<p><span>&quot;Creates each path\n&quot; + </span></p>

<p><span>&quot;Usage:MakeDirectories -d
path1 ...\n&quot; + </span></p>

<p><span>&quot;Deletes each path\n&quot; + </span></p>

<p><span>&quot;Usage:MakeDirectories -r
path1 path2\n&quot; + </span></p>

<p><span>&quot;Renames from path1 to path2&quot;);
</span></p>

<p><span>System.exit(1); </span></p>

<p><span>} </span></p>

<p><span>private static void fileData(File
f) { </span></p>

<p><span>System.out.println( </span></p>

<p><span>&quot;Absolute path: &quot; +
f.getAbsolutePath() + </span></p>

<p><span>&quot;\n Can read: &quot; +
f.canRead() + </span></p>

<p><span>&quot;\n Can write: &quot; +
f.canWrite() + </span></p>

<p><span>&quot;\n getName: &quot; +
f.getName() + </span></p>

<p><span>&quot;\n getParent: &quot; +
f.getParent() + </span></p>

<p><span>&quot;\n getPath: &quot; +
f.getPath() + </span></p>

<p><span>&quot;\n length: &quot; +
f.length() + </span></p>

<p><span>&quot;\n lastModified: &quot; +
f.lastModified()); </span></p>

<p><span>if(f.isFile()) </span></p>

<p><span>System.out.println(&quot;It</span><span>'</span><span>s a file&quot;); </span></p>

<p><span>else if(f.isDirectory()) </span></p>

<p><span>System.out.println(&quot;It</span><span>'</span><span>s a directory&quot;); </span></p>

<p><span>} </span></p>

<p><span>public static void main(String[]
args) { </span></p>

<p><span>if(args.length &lt; 1) usage(); </span></p>

<p><span>if(args[0].equals(&quot;-r&quot;))
{ </span></p>

<p><span>if(args.length != 3) usage(); </span></p>

<p><span>File </span></p>

<p><span>old = new File(args[1]), </span></p>

<p><span>rname = new File(args[2]); </span></p>

<p><span>old.renameTo(rname); </span></p>

<p><span>fileData(old); </span></p>

<p><span>fileData(rname); </span></p>

<p><span>return; // Exit main </span></p>

<p><span>} </span></p>

<p><span>int count = 0; </span></p>

<p><span>boolean del = false; </span></p>

<p><span>if(args[0].equals(&quot;-d&quot;))
{ </span></p>

<p><span>count++; </span></p>

<p><span>del = true; </span></p>

<p><span>} </span></p>

<p><span>count--; </span></p>

<p><span>while(++count &lt; args.length) { </span></p>

<p><span>File f = new File(args[count]); </span></p>

<p><span>if(f.exists()) { </span></p>

<p><span>System.out.println(f + &quot;
exists&quot;); </span></p>

<p><span>if(del) { </span></p>

<p><span>System.out.println(&quot;deleting...&quot;
+ f); </span></p>

<p><span>f.delete(); </span></p>

<p><span>} </span></p>

<p><span>} </span></p>

<p><span>else { // Doesn</span><span>'</span><span>t exist </span></p>

<p><span>if(!del) { </span></p>

<p><span>f.mkdirs(); </span></p>

<p><i><span>I/O 655 </span></i></p>

<p><span>System.out.println(&quot;created
&quot; + f); </span></p>

<p><span>} </span></p>

<p><span>} </span></p>

<p><span>fileData(f); </span></p>

<p><span>} </span></p>

<p><span>} </span></p>

<p><span>} /* Output: (80% match) </span></p>

<p><span>created MakeDirectoriesTest </span></p>

<p><span>Absolute path:
d:\aaa-TIJ4\code\io\MakeDirectoriesTest </span></p>

<p><span>Can read: true </span></p>

<p><span>Can write: true </span></p>

<p><span>getName: MakeDirectoriesTest </span></p>

<p><span>getParent: null </span></p>

<p><span>getPath: MakeDirectoriesTest </span></p>

<p><span>length: 0 </span></p>

<p><span>lastModified: 1101690308831 </span></p>

<p><span>It</span><span>'</span><span>s a directory </span></p>

<p><span>*///:~ </span></p>

<p><span>In <b>fileData( ) </b>you can see various file investigation
methods used to display information about the file or directory path. </span></p>

<p><span>The first method that's exercised by <b>main( ) </b>is <b>renameTo(
)</b>, which allows you to rename (or move) a file to an entirely new path
represented by the argument, which is another <b>File </b>object. This also
works with directories of any length. </span></p>

<p><span>If you experiment with the preceding program, you'll find
that you can make a directory path of any complexity, because <b>mkdirs( ) </b>will
do all the work for you. </span></p>

<p><b><span>Exercise 6: </span></b><span>(5) Use <b>ProcessFiles </b>to
find all the Java source-code files in a particular directory subtree that have
been modified after a particular date. </span></p>

<h2><a name="InputAndOutput">Input and output</a></h2>

<p><span>Programming language I/O libraries often use the abstraction
of a <i>stream</i>, which represents any data source or sink as an object
capable of producing or receiving pieces of data. The stream hides the details
of what happens to the data inside the actual I/O device. </span></p>

<p><span>The Java library classes for I/O are divided by input and
output, as you can see by looking at the class hierarchy in the JDK documentation.
Through inheritance, everything derived from the <b>InputStream </b>or <b>Reader
</b>classes has basic methods called <b>read( ) </b>for reading a single <b>byte
</b>or an array of <b>byte</b>s. Likewise, everything derived from <b>OutputStream
</b>or <b>Writer </b>classes has basic methods called <b>write( ) </b>for
writing a single <b>byte </b>or an array of <b>byte</b>s. However, you won't
generally use these methods; they exist so that other classes can use
themthese other classes provide a more useful interface. Thus, you'll rarely
create your stream object by using a single class, but instead will layer
multiple objects together to provide your desired functionality (this is the <i>Decorator
</i>design pattern, as you shall see in this section). The fact that you create
more than one object to produce a single stream is the primary reason that
Java's I/O library is confusing. </span></p>

<p><span>It's helpful to categorize the classes by their
functionality. In Java l.o, the library designers started by deciding that all
classes that had anything to do with input would be inherited from <b>InputStream</b>,
and all classes that were associated with output would be inherited from <b>OutputStream</b>.
</span></p>

<p><i><span>656 Thinking in Java Bruce Eckel </span></i></p>

<p><span>As is the practice in this book,
I will attempt to provide an overview of the classes, but assume that you will
use the JDK documentation to determine all the details, such as the exhaustive
list of methods of a particular class. </span></p>

<p><span>Types of <b>InputStream
</b></span></p>

<p><b><span>InputStream</span></b><span>'s job is to represent classes
that produce input from different sources. These sources can be: </span></p>

<p><span>1.<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span>An array of bytes. </span></p>

<p><span>2.<span>&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>A <b>String
</b>obj ect. </span></p>

<p><span>&nbsp;</span></p>

<p><span>1.<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>A file. </span></p>

<p><span>&nbsp;</span></p>

<p><span>1.<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>A
&quot;pipe,&quot; which works like a physical pipe: You put things in at one
end and they come out the other. </span></p>

<p><span>&nbsp;</span></p>

<p><span>1.<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>A
sequence of other streams, so you can collect them together into a single
stream. </span></p>

<p><span>&nbsp;</span></p>

<p><span>1.<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>Other
sources, such as an Internet connection. (This is covered in <i>Thinking in
Enterprise Java</i>, available at <i>www.MindView.net.) </i></span></p>

<p><span>&nbsp;</span></p>

<p><span>Each of these has an associated subclass of <b>InputStream</b>.
In addition, the <b>FilterInputStream </b>is also a type of <b>InputStream</b>,
to provide a base class for &quot;decorator&quot; classes that attach
attributes or useful interfaces to input streams. This is discussed later. </span></p>

<table >
 <tr >
  <td width=310 valign=top >
  <p><b><span>Table I/O-1</span></b><span>. <b>Types of InputStream </b></span><b><span>Class </span></b></p>
  </td>
  <td width=149 valign=top >
  <p><b><span>Function
  </span></b></p>
  </td>
  <td width=149 colspan=2 valign=top >
  <p><b><span>Constructor
  arguments </span></b></p>
  </td>
 </tr>
 <tr >
  <td width=609 colspan=4 valign=top >
  <p><b><span>How
  to use it </span></b></p>
  </td>
 </tr>
 <tr >
  <td width=310 rowspan=2 valign=top >
  <p><b><span>ByteArray-InputStream
  </span></b></p>
  </td>
  <td width=149 rowspan=2 valign=top >
  <p><span>Allows
  a buffer in memory to be used as an <b>InputStream. </b></span></p>
  </td>
  <td width=149 colspan=2 valign=top >
  <p><span>The
  buffer from which to extract the bytes. </span></p>
  </td>
 </tr>
 <tr >
  <td width=14 valign=top >
  <p><span>As
  a source of data: Connect it to a <b>FilterlnputStream </b>object to provide
  a useful interface. </span></p>
  </td>
  <td 
  width=135><p>&nbsp;</td>
 </tr>
 <tr >
  <td width=310 rowspan=2 valign=top >
  <p><b><span>StringBuffer-InputStream
  </span></b></p>
  </td>
  <td width=149 rowspan=2 valign=top >
  <p><span>Converts
  a <b>String </b>into an <b>InputStream. </b></span></p>
  </td>
  <td width=149 colspan=2 valign=top >
  <p><span>A
  <b>String</b>. The underlying implementation actually uses a <b>StringBuffer</b>.
  </span></p>
  </td>
 </tr>
 <tr >
  <td width=14 valign=top >
  <p><span>As
  a source of data: Connect it to a <b>FilterlnputStream </b>object to provide
  a useful interface. </span></p>
  </td>
  <td 
  width=135><p>&nbsp;</td>
 </tr>
 <tr >
  <td width=310 rowspan=2 valign=top >
  <p><b><span>File-InputStream
  </span></b></p>
  </td>
  <td width=149 rowspan=2 valign=top >
  <p><span>For
  reading information from a file. </span></p>
  </td>
  <td width=149 colspan=2 valign=top >
  <p><span>A
  <b>String </b>representing the file name, or a <b>File </b>or <b>FileDescriptor
  </b>object. </span></p>
  </td>
 </tr>
 <tr >
  <td width=14 valign=top >
  <p><span>As
  a source of data: Connect it to a <b>FilterlnputStream </b>object to provide
  a useful interface. </span></p>
  </td>
  <td  width=135><p>&nbsp;</td>
 </tr>
</table>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p><span>Types of <b>OutputStream
</b></span></p>

<p><span>This category
includes the classes that decide where your output will go: an array of bytes
(but not a <b>String</b>presumably, you can create one using the array of
bytes), a file, or a &quot;pipe.&quot; </span></p>

<p><span>In addition,
the <b>FilterOutputStream </b>provides a base class for &quot;decorator&quot;
classes that attach attributes or useful interfaces to output streams. This is
discussed later. </span></p>

<table >
 <tr >
  <td width=304 valign=top >
  <p><b><span>Table I/O-2</span></b><span>. <b>Types of
  OutputStream Class </b></span></p>
  </td>
  <td width=152 valign=top >
  <p><b><span>Function </span></b></p>
  </td>
  <td width=152 colspan=2 valign=top >
  <p><b><span>Constructor arguments </span></b></p>
  </td>
 </tr>
 <tr >
  <td width=609 colspan=4 valign=top >
  <p><b><span>How to use it </span></b></p>
  </td>
 </tr>
 <tr >
  <td width=304 rowspan=2 valign=top >
  <p><b><span>ByteArray-OutputStream </span></b></p>
  </td>
  <td width=152 rowspan=2 valign=top >
  <p><span>Creates a buffer in
  memory. All the data that you send to the stream is placed in this buffer. </span></p>
  </td>
  <td width=152 colspan=2 valign=top >
  <p><span>Optional initial size of
  the buffer. </span></p>
  </td>
 </tr>
 <tr >
  <td width=14 valign=top >
  <p><span>To designate the destination
  of your data: Connect it to a <b>FilterOutputStream </b>object to provide a
  useful interface. </span></p>
  </td>
  <td 
  width=138><p>&nbsp;</td>
 </tr>
 <tr >
  <td width=304 valign=top >
  <p><b><span>File-OutputStream </span></b></p>
  </td>
  <td width=152 valign=top >
  <p><span>For sending information
  to a file. </span></p>
  </td>
  <td width=152 colspan=2 valign=top >
  <p><span>A <b>String </b>representing
  the file name, or a <b>File </b>or <b>FileDescriptor </b>object. </span></p>
  </td>
 </tr>
</table>

<p>&nbsp;</p>

<p><sup><span>1 </span></sup><span>It's not clear
that this was a good design decision, especially compared to the simplicity of
I/O libraries in other languages. But it's the justification for the decision. </span></p>

<p><span>&nbsp;</span></p>

<p><span>Adding attributes </span></p>

<p><span>and useful interfaces </span></p>

<p><span>Decorators were introduced
in the <i>Generics </i>chapter, on page 717. The Java I/O library requires many
different combinations of features, and this is the justification for using the
Decorator design pattern.</span><span>1
</span><span>The reason
for the existence of the &quot;filter&quot; classes in the Java I/O library is
that the abstract &quot;filter&quot; class is the base class for all the
decorators. A decorator must have the same interface as the object it
decorates, but the decorator can also extend the interface, which occurs in
several of the &quot;filter&quot; classes. </span></p>

<p><span>There is a drawback to
Decorator, however. Decorators give you much more flexibility while you're
writing a program (since you can easily mix and match attributes), but they add
complexity to your code. The reason that the Java I/O library is awkward to use
is that you must create many classesthe &quot;core&quot; I/O type plus all the
decoratorsin order to get the single I/O object that you want. </span></p>

<p><span>The classes that provide
the decorator interface to control a particular <b>InputStream </b>or <b>OutputStream
</b>are the <b>FilterlnputStream </b>and <b>FilterOutputStream</b>, which don't
have very intuitive names. <b>FilterlnputStream </b>and <b>FilterOutputStream </b>are
derived from the base classes of the I/O library, <b>InputStream </b>and <b>OutputStream</b>,
which is a key requirement of the decorator (so that it provides the common
interface to all the objects that are being decorated). </span></p>

<p><span>Reading
from an <b>InputStream </b></span><span>with </span><b><span>FilterlnputStream </span></b></p>

<p><span>The <b>FilterlnputStream </b>classes
accomplish two significantly different things. <b>DatalnputStream </b>allows
you to read different types of primitive data as well as <b>String </b>objects.
(All the methods start with &quot;read,&quot; such as <b>readByte( )</b>, <b>readFloat(
)</b>, etc.) This, along with its companion <b>DataOutputStream</b>, allows you
to move primitive data from one place to another via a stream. These
&quot;places&quot; are determined by the classes in Table I/O-1. </span></p>

<p><span>The remaining <b>FilterlnputStream
</b>classes modify the way an <b>InputStream </b>behaves internally: whether
it's buffered or unbuffered, whether it keeps track of the lines it's reading
(allowing you to ask for line numbers or set the line number), and whether you
can push back a single character. The last two classes look a lot like support
for building a compiler (they were probably added to support the experiment of
&quot;building a Java compiler in Java&quot;), so you probably won't use them
in general programming. </span></p>

<p><span>You'll need to buffer your
input almost every time, regardless of the I/O device you're connecting to, so
it would have made more sense for the I/O library to have a special case (or
simply a method call) for unbuffered input rather than buffered input. </span></p>

<table >
 <tr >
  <td width=303 valign=top >
  <p><b><span>Table I/O-3</span></b><span>. <b>Types
  of FilterlnputStream </b></span><b><span>Class </span></b></p>
  </td>
  <td width=151 valign=top >
  <p><b><span>Function </span></b></p>
  </td>
  <td width=153 colspan=2 valign=top >
  <p><b><span>Constructor arguments </span></b></p>
  </td>
 </tr>
 <tr >
  <td width=607 colspan=4 valign=top >
  <p><b><span>How to use it </span></b></p>
  </td>
 </tr>
 <tr >
  <td width=303 rowspan=2 valign=top >
  <p><b><span>Data-InputStream </span></b></p>
  </td>
  <td width=151 rowspan=2 valign=top >
  <p><span>Used in concert with <b>DataOutputStream,
  </b>so you can read primitives <b>(int, char, long, </b>etc.) from a stream
  in a portable fashion. </span></p>
  </td>
  <td width=153 colspan=2 valign=top >
  <p><b><span>InputStream </span></b></p>
  </td>
 </tr>
 <tr >
  <td width=16 valign=top >
  <p><span>Contains a full
  interface to allow you to read primitive types. </span></p>
  </td>
  <td 
  width=137><p>&nbsp;</td>
 </tr>
 <tr >
  <td width=303 rowspan=2 valign=top >
  <p><b><span>Buffered- </span></b></p>
  <p><b><span>InputStream </span></b></p>
  </td>
  <td width=151 rowspan=2 valign=top >
  <p><span>Use this to prevent a
  physical read every time you want more data. You're saying, &quot;Use a
  buffer.&quot; </span></p>
  </td>
  <td width=153 colspan=2 valign=top >
  <p><b><span>InputStream, </span></b><span>with optional buffer
  size. </span></p>
  </td>
 </tr>
 <tr >
  <td width=16 valign=top >
  <p><span>This doesn't provide an
  interface per se. It just adds buffering to the process. Attach an interface
  object. </span></p>
  </td>
  <td 
  width=137><p>&nbsp;</td>
 </tr>
 <tr >
  <td width=303 rowspan=2 valign=top >
  <p><b><span>LineNumber-InputStream </span></b></p>
  </td>
  <td width=151 rowspan=2 valign=top >
  <p><span>Keeps track of line
  numbers in the input stream; you can call <b>getLineNumber( ) </b>and <b>setLineNumber
  (int)</b>. </span></p>
  </td>
  <td width=153 colspan=2 valign=top >
  <p><b><span>InputStream </span></b></p>
  </td>
 </tr>
 <tr >
  <td width=16 valign=top >
  <p><span>This just adds line
  numbering, so you'll probably attach an interface object. </span></p>
  </td>
  <td 
  width=137><p>&nbsp;</td>
 </tr>
 <tr >
  <td width=303 rowspan=2 valign=top >
  <p><b><span>Pushback-InputStream </span></b></p>
  </td>
  <td width=151 rowspan=2 valign=top >
  <p><span>Has a one-byte pushback
  buffer so that you can push back the last character read. </span></p>
  </td>
  <td width=153 colspan=2 valign=top >
  <p><b><span>InputStream </span></b></p>
  </td>
 </tr>
 <tr >
  <td width=16 valign=top >
  <p><span>Generally used in the </span></p>
  </td>
  <td  width=137><p>&nbsp;</td>
 </tr>
</table>

<p><span>Writing
to an <b>OutputStream </b></span></p>

<p><span>with <b>FilterOutputStream
</b></span></p>

<p><span>The complement
to <b>DatalnputStream </b>is <b>DataOutputStream</b>, which formats each of the
primitive types and <b>String </b>objects onto a stream in such a way that any <b>DatalnputStream</b>,
on any machine, can read them. All the methods start with &quot;write,&quot;
such as <b>writeByte( )</b>, <b>writeFloat( )</b>, etc. </span></p>

<p><span>The original
intent of <b>PrintStream </b>was to print all of the primitive data types and <b>String
</b>objects in a viewable format. This is different from <b>DataOutputStream</b>,
whose goal is to put data elements on a stream in a way that <b>DatalnputStream
</b>can portably reconstruct them. </span></p>

<p><span>The two
important methods in <b>PrintStream </b>are <b>print( ) </b>and <b>println( )</b>,
which are overloaded to print all the various types. The difference between <b>print(
) </b>and <b>println( ) </b>is that the latter adds a newline when it's done. </span></p>

<p><b><span>PrintStream </span></b><span>can be
problematic because it traps all IOExceptions (you must explicitly test the
error status with <b>checkError( )</b>, which returns <b>true </b>if an error
has occurred). Also, <b>PrintStream </b>doesn't internationalize properly and
doesn't handle line breaks in a platform-independent way. These problems are
solved with <b>PrintWriter</b>, described later. </span></p>

<p><b><span>BufferedOutputStream
</span></b><span>is a modifier and tells the stream to use buffering so you don't
get a physical write every time you write to the stream. You'll probably always
want to use this when doing output. </span></p>

<table >
 <tr >
  <td width=307 valign=top >
  <p><b><span>Table I/O-4</span></b><span>. <b>Types of
  FilterOutputStream Class </b></span></p>
  </td>
  <td width=148 valign=top >
  <p><b><span>Function </span></b></p>
  </td>
  <td width=148 colspan=2 valign=top >
  <p><b><span>Constructor arguments </span></b></p>
  </td>
 </tr>
 <tr >
  <td width=604 colspan=4 valign=top >
  <p><b><span>How to use it </span></b></p>
  </td>
 </tr>
 <tr >
  <td width=307 rowspan=2 valign=top >
  <p><b><span>Data-OutputStream </span></b></p>
  </td>
  <td width=148 rowspan=2 valign=top >
  <p><span>Used in concert with <b>DataInputStream
  </b>so you can write primitives (<b>int</b>, <b>char</b>, <b>long</b>, etc.)
  to a stream in a portable fashion. </span></p>
  </td>
  <td width=148 colspan=2 valign=top >
  <p><b><span>OutputStream </span></b></p>
  </td>
 </tr>
 <tr >
  <td width=14 valign=top >
  <p><span>Contains a full
  interface to allow you to write primitive types. </span></p>
  </td>
  <td 
  width=134><p>&nbsp;</td>
 </tr>
 <tr >
  <td width=307 rowspan=2 valign=top >
  <p><b><span>PrintStream </span></b></p>
  </td>
  <td width=148 rowspan=2 valign=top >
  <p><span>For producing formatted
  output. While <b>DataOutputStream </b>handles the <i>storage </i>of data, <b>PrintStream
  </b>handles <i>display. </i></span></p>
  </td>
  <td width=148 colspan=2 valign=top >
  <p><b><span>OutputStream, </span></b><span>with optional <b>boolean
  </b>indicating that the buffer is flushed with every newline. </span></p>
  </td>
 </tr>
 <tr >
  <td width=14 valign=top >
  <p><span>Should be the
  &quot;final&quot; </span></p>
  </td>
  <td  width=134><p>&nbsp;</td>
 </tr>
</table>

<p>&nbsp;</p>

<p>&nbsp;</p>

<h2><a name="ReadersAndWriters">Readers and Writers</a></h2>

<p><span>Java 1.1 made
significant modifications to the fundamental I/O stream library. When you see
the <b>Reader </b>and <b>Writer </b>classes, your first thought (like mine)
might be that these were meant to replace the <b>InputStream </b>and <b>OutputStream
</b>classes. But that's not the case. Although some aspects of the original
streams library are deprecated (if you use them you will receive a warning from
the compiler), the <b>InputStream </b>and <b>OutputStream </b>classes still
provide valuable functionality in the form of byte-oriented I/O, whereas the <b>Reader
</b>and <b>Writer </b>classes provide Unicode-compliant, character-based I/O.
In addition: </span></p>

<p><span>1.<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>Java 1.1 added
new classes into the <b>InputStream </b>and <b>OutputStream </b>hierarchy, so
it's obvious those hierarchies weren't being replaced. </span></p>

<p><span>2.<span>&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span>There are times when you must use classes from the
&quot;byte&quot; hierarchy <i>in combination </i>with classes in the
&quot;character&quot; hierarchy. To accomplish this, there are &quot;adapter&quot;
classes: <b>InputStreamReader </b>converts an <b>InputStream </b>to a <b>Reader</b>,
and <b>OutputStreamWriter </b>converts an <b>OutputStream </b>to a <b>Writer</b>.
</span></p>

<p><span>&nbsp;</span></p>

<p><span>The most
important reason for the <b>Reader </b>and <b>Writer </b>hierarchies is for
internationalization. The old I/O stream hierarchy supports only 8-bit byte
streams and doesn't handle the 16-bit Unicode characters well. Since Unicode is
used for internationalization (and Java's native <b>char </b>is 16-bit
Unicode), the <b>Reader </b>and <b>Writer </b>hierarchies were added to support
Unicode in all I/O operations. In addition, the new libraries are designed for
faster operations than the old. </span></p>

<p><span>Sources
and sinks of data </span></p>

<p><span>Almost all of
the original Java I/O stream classes have corresponding <b>Reader </b>and <b>Writer
</b>classes to provide native Unicode manipulation. However, there are some
places where the byte-oriented <b>InputStream</b>s and <b>OutputStream</b>s are
the correct solution; in particular, thejava.util.zip libraries are
byte-oriented rather than char-oriented. So the most sensible approach to take
is to <i>try </i>to use the <b>Reader </b>and <b>Writer </b>classes whenever
you can. You'll discover the situations when you have to use the byte-oriented
libraries because your code won't compile. </span></p>

<table >
 <tr >
  <td width=373 valign=top >
  <p><span>Here is a table that
  shows the correspondence between the sources and sinks of information (that
  is, where the data physically comes from or goes to) in the two hierarchies. <b>Sources
  &amp; sinks: </b></span></p>
  <p><b><span>Java 1.0 class </span></b></p>
  </td>
  <td width=210 valign=top >
  <p><b><span>Corresponding Java 1.1
  class </span></b></p>
  </td>
 </tr>
 <tr >
  <td width=373 valign=top >
  <p><b><span>InputStream </span></b></p>
  </td>
  <td width=210 valign=top >
  <p><b><span>Reader </span></b></p>
  <p><span>adapter: </span></p>
  <p><b><span>InputStreamReader </span></b></p>
  </td>
 </tr>
 <tr >
  <td width=373 valign=top >
  <p><b><span>OutputStream </span></b></p>
  </td>
  <td width=210 valign=top >
  <p><b><span>Writer </span></b></p>
  <p><span>adapter: </span></p>
  <p><b><span>OutputStreamWriter </span></b></p>
  </td>
 </tr>
 <tr >
  <td width=373 valign=top >
  <p><b><span>FilelnputStream </span></b></p>
  </td>
  <td width=210 valign=top >
  <p><b><span>FileReader </span></b></p>
  </td>
 </tr>
 <tr >
  <td width=373 valign=top >
  <p><b><span>FileOutputStream </span></b></p>
  </td>
  <td width=210 valign=top >
  <p><b><span>FileWriter </span></b></p>
  </td>
 </tr>
 <tr >
  <td width=373 valign=top >
  <p><b><span>StringBufferlnputStream </span></b></p>
  <p><span>(deprecated) </span></p>
  </td>
  <td width=210 valign=top >
  <p><b><span>StringReader </span></b></p>
  </td>
 </tr>
 <tr >
  <td width=373 valign=top >
  <p><span>(no corresponding class)
  </span></p>
  </td>
  <td width=210 valign=top >
  <p><b><span>StringWriter </span></b></p>
  </td>
 </tr>
 <tr >
  <td width=373 valign=top >
  <p><b><span>ByteArrayInputStream </span></b></p>
  </td>
  <td width=210 valign=top >
  <p><b><span>CharArrayReader </span></b></p>
  </td>
 </tr>
 <tr >
  <td width=373 valign=top >
  <p><b><span>ByteArrayOutputStream </span></b></p>
  </td>
  <td width=210 valign=top >
  <p><b><span>CharArrayWriter </span></b></p>
  </td>
 </tr>
 <tr >
  <td width=373 valign=top >
  <p><b><span>PipedInputStream </span></b></p>
  </td>
  <td width=210 valign=top >
  <p><b><span>PipedReader </span></b></p>
  </td>
 </tr>
 <tr >
  <td width=373 valign=top >
  <p><b><span>PipedOutputStream </span></b></p>
  </td>
  <td width=210 valign=top >
  <p><b><span>PipedWriter </span></b></p>
  </td>
 </tr>
</table>

<p><span>In general,
you'll find that the interfaces for the two different hierarchies are similar,
if not identical. </span></p>

<p><span>Modifying
stream behavior </span></p>

<p><span>For <b>InputStream</b>s
and <b>OutputStream</b>s, streams were adapted for particular needs using
&quot;decorator&quot; subclasses of <b>FilterInputStream </b>and <b>FilterOutputStream</b>.
The <b>Reader </b>and <b>Writer </b>class hierarchies continue the use of this
ideabut not exactly. </span></p>

<table >
 <tr >
  <td width=384 valign=top >
  <p><span>In the following table,
  the correspondence is a rougher approximation than in the previous table. The
  difference is because of the class organization; although <b>BufferedOutputStream
  </b>is a subclass of <b>FilterOutputStream</b>, <b>BufferedWriter </b>is <i>not
  </i>a subclass of <b>FilterWriter </b>(which, even though it is <b>abstract</b>,
  has no subclasses and so appears to have been put in either as a placeholder
  or simply so you don't wonder where it is). However, the interfaces to the
  classes are quite a close match. <b>Filters: </b></span></p>
  <p><b><span>Java 1.0 class </span></b></p>
  </td>
  <td width=221 valign=top >
  <p><b><span>Corresponding Java 1.1
  class </span></b></p>
  </td>
 </tr>
 <tr >
  <td width=384 valign=top >
  <p><b><span>FilterInputStream </span></b></p>
  </td>
  <td width=221 valign=top >
  <p><b><span>FilterReader </span></b></p>
  </td>
 </tr>
 <tr >
  <td width=384 valign=top >
  <p><b><span>FilterOutputStream </span></b></p>
  </td>
  <td width=221 valign=top >
  <p><b><span>FilterWriter </span></b><span>(abstract class with no
  subclasses) </span></p>
  </td>
 </tr>
 <tr >
  <td width=384 valign=top >
  <p><b><span>BufferedInputStream </span></b></p>
  </td>
  <td width=221 valign=top >
  <p><b><span>BufferedReader </span></b></p>
  <p><span>(also has <b>readLine( )</b>)
  </span></p>
  </td>
 </tr>
 <tr >
  <td width=384 valign=top >
  <p><b><span>BufferedOutputStream </span></b></p>
  </td>
  <td width=221 valign=top >
  <p><b><span>BufferedWriter </span></b></p>
  </td>
 </tr>
 <tr >
  <td width=384 valign=top >
  <p><b><span>DataInputStream </span></b></p>
  </td>
  <td width=221 valign=top >
  <p><span>Use <b>DataInputStream </b></span></p>
  <p><span>(except when you need to
  use <b>readLine( )</b>, when you should use a </span></p>
  </td>
 </tr>
</table>

<p><span>There's one
direction that's quite clear: Whenever you want to use <b>readLine( )</b>, you
shouldn't do it with a <b>DataInputStream </b>(this is met with a deprecation
message at compile time), but instead use a <b>BufferedReader</b>. Other than
this, <b>DataInputStream </b>is still a &quot;preferred&quot; member of the I/O
library. </span></p>

<p><span>To make the
transition to using a <b>PrintWriter </b>easier, it has constructors that take
any <b>OutputStream </b>object as well as <b>Writer </b>objects. <b>PrintWriter</b>'s
formatting interface is virtually the same as <b>PrintStream</b>. </span></p>

<p><span>In Java SE5, <b>PrintWriter
</b>constructors were added to simplify the creation of files when writing
output, as you shall see shortly. </span></p>

<p><span>One <b>PrintWriter
</b>constructor also has an option to perform automatic flushing, which happens
after every <b>println( ) </b>if the constructor flag is set. </span></p>

<p><span>Unchanged
classes </span></p>

<table >
 <tr >
  <td width=466 valign=top >
  <p><span>Some
  classes were left unchanged between Java 1.0 and Java 1.1: <b>Java 1.0
  classes without corresponding Java 1.1 classes </b></span></p>
  </td>
 </tr>
 <tr >
  <td width=466 valign=top >
  <p><b><span>DataOutputStream </span></b></p>
  </td>
 </tr>
 <tr >
  <td width=466 valign=top >
  <p><b><span>File </span></b></p>
  </td>
 </tr>
 <tr >
  <td width=466 valign=top >
  <p><b><span>RandomAccessFile </span></b></p>
  </td>
 </tr>
 <tr >
  <td width=466 valign=top >
  <p><b><span>SequenceInputStream </span></b></p>
  </td>
 </tr>
</table>

<p>&nbsp;</p>

<p><b><span>DataOutputStream</span></b><span>, in
particular, is used without change, so for storing and retrieving data in a
transportable format, you use the <b>InputStream </b>and <b>OutputStream </b>hierarchies.
</span></p>

<p><span>Off by itself: </span></p>

<h2><a name="RandomAccessFile">RandomAccessFile</a></h2>

<p><b><span>RandomAccessFile
</span></b><span>is used for files containing records of known size so that you can
move from one record to another using <b>seek( )</b>, then read or change the
records. The records don't have to be the same size; you just have to determine
how big they are and where they are placed in the file. </span></p>

<p><span>At first it's
a little bit hard to believe that <b>RandomAccessFile </b>is not part of the <b>InputStream
</b>or <b>OutputStream </b>hierarchy. However, it has no association with those
hierarchies other than that it happens to implement the <b>DataInput </b>and <b>DataOutput
</b>interfaces (which are also implemented by <b>DataInputStream </b>and <b>DataOutputStream</b>).
It doesn't even use any of the functionality of the existing <b>InputStream </b>or
<b>OutputStream </b>classes; it's a completely separate class, written from
scratch, with all of its own (mostly native) methods. The reason for this may
be that <b>RandomAccessFile </b>has essentially different behavior than the
other I/O types, since you can move forward and backward within a file. In any
event, it stands alone, as a direct descendant of <b>Object</b>. </span></p>

<p><span>Essentially, a
<b>RandomAccessFile </b>works like a <b>DataInputStream </b>pasted together
with a <b>DataOutputStream</b>, along with the methods <b>getFilePointer( ) </b>to
find out where you are in the file, <b>seek( ) </b>to move to a new point in
the file, and <b>length( ) </b>to determine the maximum size of the file. In
addition, the constructors require a second argument (identical to <b>fopen( ) </b>in
C) indicating whether you are just randomly reading (&quot;<b>r</b>&quot;) or
reading and writing (&quot;<b>rw</b>&quot;). There's no support for write-only
files, which could suggest that <b>RandomAccessFile </b>might have worked well
if it were inherited from <b>DataInputStream</b>. </span></p>

<p><span>The seeking
methods are available only in <b>RandomAccessFile</b>, which works for files
only. <b>BufferedInputStream </b>does allow you to <b>mark( ) </b>a position
(whose value is held in a single internal variable) and <b>reset( ) </b>to that
position, but this is limited and not very useful. </span></p>

<p><span>Most, if not
all, of the <b>RandomAccessFile </b>functionality is superseded as of JDK 1.4
with the <b>nio </b><i>memory-mapped files</i>, which will be described later
in this chapter. </span></p>

<p><span>Typical uses of I/O
streams </span></p>

<p><span>Although you
can combine the I/O stream classes in many different ways, you'll probably just
use a few combinations. The following examples can be used as a basic reference
for typical I/O usage. </span></p>

<p><span>In these
examples, exception handing will be simplified by passing exceptions out to the
console, but this is appropriate only in small examples and utilities. In your
code you'll want to consider more sophisticated error-handling approaches. </span></p>

<p><span>Buffered
input file </span></p>

<p><span>To open a file
for character input, you use a <b>FileInputReader </b>with a <b>String </b>or a
<b>File </b>object as the file name. For speed, you'll want that file to be
buffered so you give the resulting reference to the constructor for a <b>BufferedReader</b>.
Since <b>BufferedReader </b>also provides the <b>readLine( ) </b>method, this
is your final object and the interface you read from. When <b>readLine( ) </b>returns
<b>null</b>, you're at the end of the file. </span></p>

<p><span>//:
io/BufferedInputFile.java </span></p>

<p><span>import
java.io.*; </span></p>

<p><i><span>I/O
665 666 Thinking in Java Bruce Eckel </span></i></p>

<p><sup><span>2 </span></sup><span>In the original
design, <b>close( ) </b>was supposed to be called when <b>finalize( ) </b>ran,
and you will see <b>finalize( ) </b>defined this way for I/O classes. However,
as is discussed elsewhere in this book, the <b>finalize( ) </b>feature didn't
work out the way the Java designers originally envisioned it (that is to say,
it's irreparably broken), so the only safe approach is to explicitly call <b>close(
) </b>for files. </span></p>

<p><span>&nbsp;</span></p>

<p><span>public class
BufferedInputFile { </span></p>

<p><span>// Throw
exceptions to console: </span></p>

<p><span>public static
String </span></p>

<p><span>read(String
filename) throws IOException { </span></p>

<p><span>// Reading input
by lines: </span></p>

<p><span>BufferedReader
in = new BufferedReader( </span></p>

<p><span>new
FileReader(filename)); </span></p>

<p><span>String s; </span></p>

<p><span>StringBuilder sb
= new StringBuilder(); </span></p>

<p><span>while((s =
in.readLine())!= null) </span></p>

<p><span>sb.append(s +
&quot;\n&quot;); </span></p>

<p><span>in.close(); </span></p>

<p><span>return
sb.toString(); </span></p>

<p><span>} </span></p>

<p><span>public static
void main(String[] args) </span></p>

<p><span>throws
IOException { </span></p>

<p><span>System.out.print(read(&quot;BufferedInputFile.java&quot;));
</span></p>

<p><span>} </span></p>

<p><span>} /* (Execute to
see output) *///:~ </span></p>

<p><span>The <b>StringBuilder sb </b>is
used to accumulate the entire contents of the file (including newlines that
must be added since <b>readLine( ) </b>strips them off). Finally, <b>close( ) </b>is
called to close the file.</span><span>2
</span></p>

<p><b><span>Exercise 7: </span></b><span>(2) Open a text file so
that you can read the file one line at a time. Read each line as a <b>String </b>and
place that <b>String </b>object into a <b>LinkedList</b>. Print all of the
lines in the <b>LinkedList </b>in reverse order. </span></p>

<p><b><span>Exercise 8: </span></b><span>(1) Modify Exercise 7 so
that the name of the file you read is provided as a command-line argument. </span></p>

<p><b><span>Exercise 9: </span></b><span>(1) Modify Exercise 8 to
force all the lines in the <b>LinkedList </b>to uppercase and send the results
to <b>System.out</b>. </span></p>

<p><b><span>Exercise 10: </span></b><span>(2) Modify Exercise 8 to
take additional command-line arguments of words to find in the file. Print all
lines in which any of the words match. </span></p>

<p><b><span>Exercise 11: </span></b><span>(2) In the <b>innerclasses/GreenhouseController.java
</b>example, <b>GreenhouseController </b>contains a hard-coded set of events.
Change the program so that it reads the events and their relative times from a
text file, ((difficulty level 8): Use a <i>Factory Method </i>design pattern to
build the eventssee <i>Thinking in Patterns (with Java) </i>at <i>www.MindView.net.)
</i></span></p>

<p><span>Input from memory </span></p>

<p><span>Here, the <b>String </b>result
from <b>BufferedInputFile.read( ) </b>is used to create a <b>StringReader</b>. Then
<b>read( ) </b>is used to read each character one at a time and send it out to
the console: </span></p>

<p><span>//:
io/MemoryInput.java </span></p>

<p><span>import
java.io.*; </span></p>

<p><span>public
class MemoryInput { </span></p>

<p><span>public static
void main(String[] args) </span></p>

<p><span>throws
IOException { </span></p>

<p><span>StringReader in
= new StringReader( </span></p>

<p><span>BufferedInputFile.read(&quot;MemoryInput.java&quot;));
</span></p>

<p><span>int c; </span></p>

<p><span>while((c =
in.read()) != -1) </span></p>

<p><span>System.out.print((char)c);
</span></p>

<p><span>} </span></p>

<p><span>} /* (Execute to
see output) *///:~ </span></p>

<p><span>Note that <b>read( ) </b>returns
the next character as an <b>int </b>and thus it must be cast to a <b>char </b>to
print properly. </span></p>

<p><span>Formatted memory
input </span></p>

<p><span>To read
&quot;formatted&quot; data, you use a <b>DataInputStream</b>, which is a
byteoriented I/O class (rather than <b>char</b>-oriented). Thus you must use
all <b>InputStream </b>classes rather than <b>Reader </b>classes. Of course,
you can read anything (such as a file) as bytes using <b>InputStream </b>classes,
but here a <b>String </b>is used: </span></p>

<p><span>//:
io/FormattedMemoryInput.java </span></p>

<p><span>import
java.io.*; </span></p>

<p><span>public class
FormattedMemoryInput { </span></p>

<p><span>public static
void main(String[] args) </span></p>

<p><span>throws
IOException { </span></p>

<p><span>try { </span></p>

<p><span>DataInputStream
in = new DataInputStream( </span></p>

<p><span>new
ByteArrayInputStream( </span></p>

<p><span>BufferedInputFile.read(
</span></p>

<p><span>&quot;FormattedMemoryInput.java&quot;).getBytes()));
</span></p>

<p><span>while(true) </span></p>

<p><span>System.out.print((char)in.readByte());
</span></p>

<p><span>}
catch(EOFException e) { </span></p>

<p><span>System.err.println(&quot;End
of stream&quot;); </span></p>

<p><span>} </span></p>

<p><span>} </span></p>

<p><span>} /* (Execute to
see output) *///:~ </span></p>

<p><span>A <b>ByteArrayInputStream </b>must
be given an array of bytes. To produce this, <b>String </b>has a <b>getBytes( )
</b>method. The resulting <b>ByteArrayInputStream </b>is an appropriate <b>InputStream
</b>to hand to <b>DataInputStream</b>. </span></p>

<p><span>If you read the characters
from a <b>DataInputStream </b>one <b>byte </b>at a time using <b>readByte( )</b>,
any <b>byte </b>value is a legitimate result, so the return value cannot be
used to detect the end of input. Instead, you can use the <b>available( ) </b>method
to find out how many more characters are available. Here's an example that
shows how to read a file one <b>byte </b>at a time: </span></p>

<p><span>//:
io/TestEOF.java </span></p>

<p><span>// Testing for
end of file while reading a byte at a time. </span></p>

<p><span>import java.io.*;
</span></p>

<p><span>public class
TestEOF { </span></p>

<p><span>public static
void main(String[] args) </span></p>

<p><span>throws
IOException { </span></p>

<p><span>DataInputStream
in = new DataInputStream( </span></p>

<p><span>new
BufferedInputStream( </span></p>

<p><span>new
FileInputStream(&quot;TestEOF.java&quot;))); </span></p>

<p><span>while(in.available()
!= 0) </span></p>

<p><i><span>I/O
667 </span></i></p>

<p><span>System.out.print((char)in.readByte());
</span></p>

<p><span>} </span></p>

<p><span>} /* (Execute to
see output) *///:~ </span></p>

<p><span>Note that <b>available( ) </b>works
differently depending on what sort of medium you're reading from; it's
literally &quot;the number of bytes that can be read <i>without blocking.&quot;
</i>With a file, this means the whole file, but with a different kind of stream
this might not be true, so use it thoughtfully. </span></p>

<p><span>You could also detect the
end of input in cases like these by catching an exception. However, the use of
exceptions for control flow is considered a misuse of that feature. </span></p>

<p><span>Basic file output </span></p>

<p><span>A <b>FileWriter </b>object
writes data to a file. You'll virtually always want to buffer the output by
wrapping it in a <b>BufferedWriter </b>(try removing this wrapping to see the
impact on the performancebuffering tends to dramatically increase performance
of I/O operations). In this example, it's decorated as a <b>PrintWriter </b>to
provide formatting. The data file created this way is readable as an ordinary
text file: </span></p>

<p><span>//:
io/BasicFileOutput.java </span></p>

<p><span>import
java.io.*; </span></p>

<p><span>public class
BasicFileOutput { </span></p>

<p><span>static String
file = &quot;BasicFileOutput.out&quot;; </span></p>

<p><span>public static
void main(String[] args) </span></p>

<p><span>throws
IOException { </span></p>

<p><span>BufferedReader
in = new BufferedReader( </span></p>

<p><span>new
StringReader( </span></p>

<p><span>BufferedInputFile.read(&quot;BasicFileOutput.java&quot;)));
</span></p>

<p><span>PrintWriter out
= new PrintWriter( </span></p>

<p><span>new
BufferedWriter(new FileWriter(file))); </span></p>

<p><span>int lineCount =
1; </span></p>

<p><span>String s; </span></p>

<p><span>while((s =
in.readLine()) != null ) </span></p>

<p><span>out.println(lineCount++
+ &quot;: &quot; + s); </span></p>

<p><span>out.close(); </span></p>

<p><span>// Show the
stored file: </span></p>

<p><span>System.out.println(BufferedInputFile.read(file));
</span></p>

<p><span>} </span></p>

<p><span>} /* (Execute to
see output) *///:~ </span></p>

<p><span>As the lines are written
to the file, line numbers are added. Note that <b>LineNumberReader </b>is <i>not
</i>used, because it's a silly class and you don't need it. You can see from
this example that it's trivial to keep track of your own line numbers. </span></p>

<p><span>When the input stream is
exhausted, <b>readLine( ) </b>returns <b>null</b>. You'll see an explicit <b>close(
) </b>for <b>out</b>, because if you don't call <b>close( ) </b>for all your
output files, you might discover that the buffers don't get flushed, so the
file will be incomplete. </span></p>

<p><span>Text file output
shortcut </span></p>

<p><span>Java SE5 added a helper
constructor to <b>PrintWriter </b>so that you don't have to do all the
decoration by hand every time you want to create a text file and write to it.
Here's <b>BasicFileOutput.java </b>rewritten to use this shortcut: </span></p>

<p><span>//:
io/FileOutputShortcut.java </span></p>

<p><span>import
java.io.*; </span></p>

<p><i><span>668
Thinking in Java Bruce Eckel </span></i></p>

<p><span>public
class FileOutputShortcut { </span></p>

<p><span>static String
file = &quot;FileOutputShortcut.out&quot;; </span></p>

<p><span>public static
void main(String[] args) </span></p>

<p><span>throws
IOException { </span></p>

<p><span>BufferedReader
in = new BufferedReader( </span></p>

<p><span>new
StringReader( </span></p>

<p><span>BufferedInputFile.read(&quot;FileOutputShortcut.java&quot;)));
</span></p>

<p><span>// Here</span><span>'</span><span>s the shortcut: </span></p>

<p><span>PrintWriter out
= new PrintWriter(file); </span></p>

<p><span>int lineCount =
1; </span></p>

<p><span>String s; </span></p>

<p><span>while((s =
in.readLine()) != null ) </span></p>

<p><span>out.println(lineCount++
+ &quot;: &quot; + s); </span></p>

<p><span>out.close(); </span></p>

<p><span>// Show the
stored file: </span></p>

<p><span>System.out.println(BufferedInputFile.read(file));
</span></p>

<p><span>} </span></p>

<p><span>} /* (Execute to
see output) *///:~ </span></p>

<p><span>You still get buffering,
you just don't have to do it yourself. Unfortunately, other commonly written
tasks were not given shortcuts, so typical I/O will still involve a lot of
redundant text. However, the <b>TextFile </b>utility that is used in this book,
and which will be defined a little later in this chapter, does simplify these
common tasks. </span></p>

<p><b><span>Exercise 12: </span></b><span>(3) Modify Exercise 8 to
also open a text file so you can write text into it. Write the lines in the <b>LinkedList</b>,
along with line numbers (do not attempt to use the &quot;LineNumber&quot;
classes), out to the file. </span></p>

<p><b><span>Exercise 13</span></b><span>: </span><span>(3) Modify <b>BasicFileOutput.java
</b>so that it uses <b>LineNumberReader </b>to keep track of the line count.
Note that it's much easier to just keep track programmatically. </span></p>

<p><b><span>Exercise 14: </span></b><span>(2) Starting with <b>BasicFileOutput.java</b>,
write a program that compares the performance of writing to a file when using
buffered and unbuffered I/O. </span></p>

<p><span>Storing and
recovering data </span></p>

<p><span>A <b>PrintWriter </b>formats
data so that it's readable by a human. However, to output data for recovery by
another stream, you use a <b>DataOutputStream </b>to write the data and a <b>DataInputStream
</b>to recover the data. Of course, these streams can be anything, but the
following example uses a file, buffered for both reading and writing. <b>DataOutputStream
</b>and <b>DataInputStream </b>are byte-oriented and thus require <b>InputStream</b>s
and <b>OutputStream</b>s: </span></p>

<p><span>//:
io/StoringAndRecoveringData.java </span></p>

<p><span>import
java.io.*; </span></p>

<p><span>public class
StoringAndRecoveringData { </span></p>

<p><span>public static void
main(String[] args) </span></p>

<p><span>throws
IOException { </span></p>

<p><span>DataOutputStream
out = new DataOutputStream( </span></p>

<p><span>new
BufferedOutputStream( </span></p>

<p><span>new
FileOutputStream(&quot;Data.txt&quot;))); </span></p>

<p><span>out.writeDouble(3.14159);
</span></p>

<p><span>out.writeUTF(&quot;That
was pi&quot;); </span></p>

<p><span>out.writeDouble(1.41413);
</span></p>

<p><span>out.writeUTF(&quot;Square
root of 2&quot;); </span></p>

<p><span>out.close(); </span></p>

<p><span>DataInputStream
in = new DataInputStream( </span></p>

<p><i><span>I/O
669 670 Thinking in Java Bruce Eckel </span></i></p>

<p><sup><span>3 </span></sup><span>XML is another
way to solve the problem of moving data across different computing platforms,
and does not depend on having Java on all platforms. XML is introduced later in
this chapter. </span></p>

<p><span>&nbsp;</span></p>

<p><span>new
BufferedInputStream( </span></p>

<p><span>new
FileInputStream(&quot;Data.txt&quot;))); </span></p>

<p><span>System.out.println(in.readDouble());
</span></p>

<p><span>// Only
readUTF() will recover the </span></p>

<p><span>// Java-UTF
String properly: </span></p>

<p><span>System.out.println(in.readUTF());
</span></p>

<p><span>System.out.println(in.readDouble());
</span></p>

<p><span>System.out.println(in.readUTF());
</span></p>

<p><span>} </span></p>

<p><span>} /* Output: </span></p>

<p><span>3.14159 </span></p>

<p><span>That was pi </span></p>

<p><span>1.41413 </span></p>

<p><span>Square root of 2
</span></p>

<p><span>*///:~ </span></p>

<p><span>If you use a <b>DataOutputStream
</b>to write the data, then Java guarantees that you can accurately recover the
data using a <b>DataInputStream </b>regardless of what different platforms
write and read the data. This is incredibly valuable, as anyone knows who has
spent time worrying about platform-specific data issues. That problem vanishes
if you have Java on both platforms.</span><span>3 </span></p>

<p><span>When you are using a <b>DataOutputStream</b>,
the only reliable way to write a <b>String </b>so that it can be recovered by a
<b>DataInputStream </b>is to use UTF-8 encoding, accomplished in this example
using <b>writeUTF( ) </b>and <b>readUTF( )</b>. UTF-8 is a multi-byte format,
and the length of encoding varies according to the actual character set in use.
If you're working with ASCII or mostly ASCII characters (which occupy only
seven bits), Unicode is a tremendous waste of space and/or bandwidth, so UTF-8
encodes ASCII characters in a single byte, and non-ASCII characters in two or
three bytes. In addition, the length of the string is stored in the first two
bytes of the UTF-8 string. However, <b>writeUTF( ) </b>and <b>readUTF( ) </b>use
a special variation of UTF-8 for Java (which is completely described in the JDK
documentation for those methods), so if you read a string written with <b>writeUTF(
) </b>using a non-Java program, you must write special code in order to read
the string properly. </span></p>

<p><span>With <b>writeUTF( ) </b>and
<b>readUTF( )</b>, you can intermingle <b>String</b>s and other types of data
using a <b>DataOutputStream</b>, with the knowledge that the <b>String</b>s
will be properly stored as Unicode and will be easily recoverable with a <b>DataInputStream</b>.
</span></p>

<p><span>The <b>writeDouble( ) </b>method
stores the <b>double </b>number to the stream, and the complementary <b>readDouble(
) </b>method recovers it (there are similar methods for reading and writing the
other types). But for any of the reading methods to work correctly, you must
know the exact placement of the data item in the stream, since it would be
equally possible to read the stored <b>double </b>as a simple sequence of
bytes, or as a <b>char</b>, etc. So you must either have a fixed format for the
data in the file, or extra information must be stored in the file that you
parse to determine where the data is located. Note that object serialization or
XML (both described later in this chapter) may be easier ways to store and
retrieve complex data structures. </span></p>

<p><b><span>Exercise 15: </span></b><span>(4) Look up <b>DataOutputStream
</b>and <b>DataInputStream </b>in the JDK documentation. Starting with <b>StoringAndRecoveringData.java</b>,
create a program that stores and then retrieves all the different possible
types provided by the <b>DataOutputStream </b>and <b>DataInputStream </b>classes.
Verify that the values are stored and retrieved accurately. </span></p>

<p><span>Reading and writing </span></p>

<p><span>random-access
files </span></p>

<p><span>Using a <b>RandomAccessFile
</b>is like using a combined <b>DataInputStream </b>and <b>DataOutputStream </b>(because
it implements the same interfaces: <b>DataInput </b>and <b>DataOutput)</b>. In addition,
you can use <b>seek( ) </b>to move about in the file and change the values. </span></p>

<p><span>When using <b>RandomAccessFile</b>,
you must know the layout of the file so that you can manipulate it properly. <b>RandomAccessFile
</b>has specific methods to read and write primitives and UTF-8 strings. Here's
an example: </span></p>

<p><span>//:
io/UsingRandomAccessFile.java </span></p>

<p><span>import java.io.*;
</span></p>

<p><span>public class
UsingRandomAccessFile { </span></p>

<p><span>static String
file = &quot;rtest.dat&quot;; </span></p>

<p><span>static void
display() throws IOException { </span></p>

<p><span>RandomAccessFile
rf = new RandomAccessFile(file, &quot;r&quot;); </span></p>

<p><span>for(int i = 0; i
&lt; 7; i++) </span></p>

<p><span>System.out.println(
</span></p>

<p><span>&quot;Value
&quot; + i + &quot;: &quot; + rf.readDouble()); </span></p>

<p><span>System.out.println(rf.readUTF());
</span></p>

<p><span>rf.close(); </span></p>

<p><span>} </span></p>

<p><span>public static
void main(String[] args) </span></p>

<p><span>throws
IOException { </span></p>

<p><span>RandomAccessFile
rf = new RandomAccessFile(file, &quot;rw&quot;); </span></p>

<p><span>for(int i = 0; i
&lt; 7; i++) </span></p>

<p><span>rf.writeDouble(i*1.414);
</span></p>

<p><span>rf.writeUTF(&quot;The
end of the file&quot;); </span></p>

<p><span>rf.close(); </span></p>

<p><span>display(); </span></p>

<p><span>rf = new
RandomAccessFile(file, &quot;rw&quot;); </span></p>

<p><span>rf.seek(5*8); </span></p>

<p><span>rf.writeDouble(47.0001);
</span></p>

<p><span>rf.close(); </span></p>

<p><span>display(); </span></p>

<p><span>} </span></p>

<p><span>} /* Output: </span></p>

<p><span>Value 0: 0.0 </span></p>

<p><span>Value 1: 1.414 </span></p>

<p><span>Value 2: 2.828 </span></p>

<p><span>Value 3: 4.242 </span></p>

<p><span>Value 4: 5.656 </span></p>

<p><span>Value 5: 7.069999999999999
</span></p>

<p><span>Value 6: 8.484 </span></p>

<p><span>The end of the
file </span></p>

<p><span>Value 0: 0.0 </span></p>

<p><span>Value 1: 1.414 </span></p>

<p><span>Value 2: 2.828 </span></p>

<p><span>Value 3: 4.242 </span></p>

<p><span>Value 4: 5.656 </span></p>

<p><span>Value 5: 47.0001
</span></p>

<p><span>Value 6: 8.484 </span></p>

<p><span>The end of the
file </span></p>

<p><span>*///:~ </span></p>

<p><span>The <b>display( ) </b>method
opens a file and displays seven elements within as <b>double </b>values. In <b>main(
)</b>, the file is created, then opened and modified. Since a <b>double </b>is
always eight bytes long, to <b>seek( ) </b>to double number 5 you just multiply
<b>5*8 </b>to produce the seek value. </span></p>

<p><i><span>I/O
671 </span></i></p>

<p><span>As previously
noted, <b>RandomAccessFile </b>is effectively separate from the rest of the I/O
hierarchy, save for the fact that it implements the <b>DataInput </b>and <b>DataOutput
</b>interfaces. It doesn't support decoration, so you cannot combine it with
any of the aspects of the <b>InputStream </b>and <b>OutputStream </b>subclasses.
You must assume that a <b>RandomAccessFile </b>is properly buffered since you
cannot add that. </span></p>

<p><span>The one option you have is
in the second constructor argument: You can open a <b>RandomAccessFile </b>to
read (<b>&quot;r&quot;</b>) or read and write (<b>&quot;rw&quot;</b>). </span></p>

<p><span>You may want to consider
using <b>nio </b>memory-mapped files instead of <b>RandomAccessFile</b>. </span></p>

<p><b><span>Exercise 16: </span></b><span>(2) Look up <b>RandomAccessFile
</b>in the JDK documentation. Starting with <b>UsingRandomAccessFile.java</b>,
create a program that stores and then retrieves all the different possible
types provided by the <b>RandomAccessFile </b>class. Verify that the values are
stored and retrieved accurately. </span></p>

<p><span>Piped streams </span></p>

<p><span>The <b>PipedInputStream</b>,
<b>PipedOutputStream</b>, <b>PipedReader </b>and <b>PipedWriter </b>have been
mentioned only briefly in this chapter. This is not to suggest that they aren't
useful, but their value is not apparent until you begin to understand
concurrency, since the piped streams are used to communicate between tasks.
This is covered along with an example in the <i>Concurrency </i>chapter. </span></p>

<p><span>File reading &amp; writing utilities </span></p>

<p><span>A very common programming
task is to read a file into memory, modify it, and then write it out again. One
of the problems with the Java I/O library is that it requires you to write
quite a bit of code in order to perform these common operationsthere are no
basic helper functions to do them for you. What's worse, the decorators make it
rather hard to remember how to open files. Thus, it makes sense to add helper
classes to your library that will easily perform these basic tasks for you.
Java SE5 has added a convenience constructor to <b>PrintWriter </b>so you can
easily open a text file for writing. However, there are many other common tasks
that you will want to do over and over, and it makes sense to eliminate the
redundant code associated with those tasks. </span></p>

<p><span>Here's the <b>TextFile </b>class
that has been used in previous examples in this book to simplify reading and
writing files. It contains <b>static </b>methods to read and write text files
as a single string, and you can create a <b>TextFile </b>object that holds the
lines of the file in an <b>ArrayList </b>(so you have all the <b>ArrayList </b>functionality
while manipulating the file contents): </span></p>

<p><span>//:
net/mindview/util/TextFile.java </span></p>

<p><span>// Static
functions for reading and writing text files as </span></p>

<p><span>// a single
string, and treating a file as an ArrayList. </span></p>

<p><span>package
net.mindview.util; </span></p>

<p><span>import
java.io.*; </span></p>

<p><span>import
java.util.*; </span></p>

<p><span>public class
TextFile extends ArrayList&lt;String&gt; { </span></p>

<p><span>// Read a file
as a single string: </span></p>

<p><span>public static
String read(String fileName) { </span></p>

<p><span>StringBuilder sb
= new StringBuilder(); </span></p>

<p><span>try { </span></p>

<p><span>BufferedReader
in= new BufferedReader(new FileReader( </span></p>

<p><span>new
File(fileName).getAbsoluteFile())); </span></p>

<p><span>try { </span></p>

<p><span>String s; </span></p>

<p><i><span>672
Thinking in Java Bruce Eckel </span></i></p>

<p><span>while((s
= in.readLine()) != null) { </span></p>

<p><span>sb.append(s); </span></p>

<p><span>sb.append(&quot;\n&quot;);
</span></p>

<p><span>} </span></p>

<p><span>} finally { </span></p>

<p><span>in.close(); </span></p>

<p><span>} </span></p>

<p><span>}
catch(IOException e) { </span></p>

<p><span>throw new
RuntimeException(e); </span></p>

<p><span>} </span></p>

<p><span>return
sb.toString(); </span></p>

<p><span>} </span></p>

<p><span>// Write a
single file in one method call: </span></p>

<p><span>public static
void write(String fileName, String text) { </span></p>

<p><span>try { </span></p>

<p><span>PrintWriter out
= new PrintWriter( </span></p>

<p><span>new
File(fileName).getAbsoluteFile()); </span></p>

<p><span>try { </span></p>

<p><span>out.print(text);
</span></p>

<p><span>} finally { </span></p>

<p><span>out.close(); </span></p>

<p><span>} </span></p>

<p><span>}
catch(IOException e) { </span></p>

<p><span>throw new
RuntimeException(e); </span></p>

<p><span>} </span></p>

<p><span>} </span></p>

<p><span>// Read a file,
split by any regular expression: </span></p>

<p><span>public
TextFile(String fileName, String splitter) { </span></p>

<p><span>super(Arrays.asList(read(fileName).split(splitter)));
</span></p>

<p><span>// Regular
expression split() often leaves an empty </span></p>

<p><span>// String at the
first position: </span></p>

<p><span>if(get(0).equals(&quot;&quot;))
remove(0); </span></p>

<p><span>} </span></p>

<p><span>// Normally read
by lines: </span></p>

<p><span>public
TextFile(String fileName) { </span></p>

<p><span>this(fileName,
&quot;\n&quot;); </span></p>

<p><span>} </span></p>

<p><span>public void
write(String fileName) { </span></p>

<p><span>try { </span></p>

<p><span>PrintWriter out
= new PrintWriter( </span></p>

<p><span>new
File(fileName).getAbsoluteFile()); </span></p>

<p><span>try { </span></p>

<p><span>for(String item
: this) </span></p>

<p><span>out.println(item);
</span></p>

<p><span>} finally { </span></p>

<p><span>out.close(); </span></p>

<p><span>} </span></p>

<p><span>}
catch(IOException e) { </span></p>

<p><span>throw new
RuntimeException(e); </span></p>

<p><span>} </span></p>

<p><span>} </span></p>

<p><span>// Simple test: </span></p>

<p><span>public static
void main(String[] args) { </span></p>

<p><span>String file =
read(&quot;TextFile.java&quot;); </span></p>

<p><span>write(&quot;test.txt&quot;,
file); </span></p>

<p><span>TextFile text =
new TextFile(&quot;test.txt&quot;); </span></p>

<p><span>text.write(&quot;test2.txt&quot;);
</span></p>

<p><span>// Break into
unique sorted list of words: </span></p>

<p><span>TreeSet&lt;String&gt;
words = new TreeSet&lt;String&gt;( </span></p>

<p><span>new
TextFile(&quot;TextFile.java&quot;, &quot;\\W+&quot;)); </span></p>

<p><span>// Display the
capitalized words: </span></p>

<p><span>System.out.println(words.headSet(&quot;a&quot;));
</span></p>

<p><span>} </span></p>

<p><i><span>I/O
673 </span></i></p>

<p><span>}
/* Output: </span></p>

<p><span>[0, ArrayList,
Arrays, Break, BufferedReader, BufferedWriter, Clean, Display, File,
FileReader, FileWriter, IOException, Normally, Output, PrintWriter, Read,
Regular, RuntimeException, Simple, Static, String, StringBuilder, System,
TextFile, Tools, TreeSet, W, Write] </span></p>

<p><span>*///:~ </span></p>

<p><b><span>read( ) </span></b><span>appends each line to a <b>StringBuilder</b>,
followed by a newline, because that is stripped out during reading. Then it
returns a <b>String </b>containing the whole file. <b>write( ) </b>opens and
writes the text <b>String </b>to the file. </span></p>

<p><span>Notice that any code that
opens a file guards the file's <b>close( ) </b>call in a <b>finally </b>clause
to guarantee that the file will be properly closed. </span></p>

<p><span>The constructor uses the <b>read(
) </b>method to turn the file into a <b>String</b>, then uses <b>String.split(
) </b>to divide the result into lines along newline boundaries (if you use this
class a lot, you may want to rewrite this constructor to improve efficiency).
Alas, there is no corresponding &quot;join&quot; method, so the non-<b>static
write( ) </b>method must write the lines out by hand. </span></p>

<p><span>Because this class is
intended to trivialize the process of reading and writing files, all <b>IOException</b>s
are converted to <b>RuntimeException</b>s, so the user doesn't have to use <b>try-catch
</b>blocks. However, you may need to create another version that passes <b>IOExceptions
</b>out to the caller. </span></p>

<p><span>In <b>main( )</b>, a basic
test is performed to ensure that the methods work. </span></p>

<p><span>Although this utility did
not require much code to create, using it can save a lot of time and make your
life easier, as you'll see in some of the examples later in this chapter. </span></p>

<p><span>Another way to solve the
problem of reading text files is to use the <b>java.util.Scanner </b>class
introduced in Java SE5. However, this is only for reading files, not writing
them, and that tool (which you'll notice is nor in <b>java.io</b>) is primarily
designed for creating programming-language scanners or &quot;little
languages.&quot; </span></p>

<p><b><span>Exercise 17: </span></b><span>(4) Using <b>TextFile </b>and
a <b>Map&lt;Character,Integer&gt;</b>, create a program that counts the
occurrence of all the different characters in a file. (So if there are 12
occurrences of the letter a' in the file, the <b>Integer </b>associated with
the <b>Character </b>containing a' in the <b>Map </b>contains 12'). </span></p>

<p><b><span>Exercise 18: </span></b><span>(1) Modify <b>TextFile.java
</b>so that it passes <b>IOExceptions </b>out to the caller. </span></p>

<p><span>Reading binary files </span></p>

<p><span>This utility is similar to
<b>TextFile.java </b>in that it simplifies the process of reading binary files:
</span></p>

<p><span>//: net/mindview/util/BinaryFile.java
</span></p>

<p><span>// Utility for
reading files in binary form. </span></p>

<p><span>package
net.mindview.util; </span></p>

<p><span>import
java.io.*; </span></p>

<p><span>public class
BinaryFile { </span></p>

<p><span>public static
byte[] read(File bFile) throws IOException{ </span></p>

<p><span>BufferedInputStream
bf = new BufferedInputStream( </span></p>

<p><span>new
FileInputStream(bFile)); </span></p>

<p><span>try { </span></p>

<p><span>byte[] data =
new byte[bf.available()]; </span></p>

<p><i><span>674
Thinking in Java Bruce Eckel </span></i></p>

<p><span>bf.read(data);
</span></p>

<p><span>return data; </span></p>

<p><span>} finally { </span></p>

<p><span>bf.close(); </span></p>

<p><span>} </span></p>

<p><span>} </span></p>

<p><span>public static
byte[] </span></p>

<p><span>read(String
bFile) throws IOException { </span></p>

<p><span>return read(new
File(bFile).getAbsoluteFile()); </span></p>

<p><span>} </span></p>

<p><span>} ///:~ </span></p>

<p><span>One overloaded method
takes a <b>File </b>argument; the second takes a <b>String </b>argument, which
is the file name. Both return the resulting <b>byte </b>array. </span></p>

<p><span>The <b>available( ) </b>method
is used to produce the appropriate array size, and this particular version of
the overloaded <b>read( ) </b>method fills the array. </span></p>

<p><b><span>Exercise 19: </span></b><span>(2) Using <b>BinaryFile </b>and
a <b>Map&lt;Byte,Integer&gt;</b>, create a program that counts the occurrence
of all the different bytes in a file. </span></p>

<p><b><span>Exercise 20: </span></b><span>(4) Using <b>Directory.walk(
) </b>and <b>BinaryFile</b>, verify that all <b>.class </b>files in a directory
tree begin with the hex characters <b>CAFEBABE'</b>. </span></p>

<p><span>Standard I/O </span></p>

<p><span>The term <i>standard I/O </i>refers
to the Unix concept of a single stream of information that is used by a program
(this idea is reproduced in some form in Windows and many other operating
systems). All of the program's input can come from <i>standard input</i>, all
of its output can go to <i>standard output</i>, and all of its error messages
can be sent to <i>standard error</i>. The value of standard I/O is that
programs can easily be chained together, and one program's standard output can
become the standard input for another program. This is a powerful tool. </span></p>

<p><span>Reading from standard
input </span></p>

<p><span>Following the standard I/O
model, Java has <b>System.in</b>, <b>System.out</b>, and <b>System.err</b>.
Throughout this book, you've seen how to write to standard output using <b>System.out</b>,
which is already pre-wrapped as a <b>PrintStream </b>object. <b>System.err </b>is
likewise a <b>PrintStream</b>, but <b>System.in </b>is a raw <b>InputStream </b>with
no wrapping. This means that although you can use <b>System.out </b>and <b>System.err
</b>right away, <b>System.in </b>must be wrapped before you can read from it. </span></p>

<p><span>You'll typically read
input a line at a time using <b>readLine( )</b>. To do this, wrap <b>System.in </b>in
a <b>BufferedReader</b>, which requires you to convert <b>System.in </b>to a <b>Reader
</b>using <b>InputStreamReader</b>. Here's an example that simply echoes each
line that you type in: </span></p>

<p><span>//: io/Echo.java
</span></p>

<p><span>// How to read
from standard input. </span></p>

<p><span>// {RunByHand} </span></p>

<p><span>import
java.io.*; </span></p>

<p><span>public class
Echo { </span></p>

<p><span>public static
void main(String[] args) </span></p>

<p><span>throws
IOException { </span></p>

<p><span>BufferedReader
stdin = new BufferedReader( </span></p>

<p><span>new
InputStreamReader(System.in)); </span></p>

<p><span>String s; </span></p>

<p><i><span>I/O
675 676 Thinking in Java Bruce Eckel </span></i></p>

<p><sup><span>4 </span></sup><span>The <i>Graphical
User Interfaces </i>chapter shows an even more convenient solution for this: a
GUI program with a scrolling text area. </span></p>

<p><span>&nbsp;</span></p>

<p><span>while((s =
stdin.readLine()) != null &amp;&amp; s.length()!= 0) </span></p>

<p><span>System.out.println(s);
</span></p>

<p><span>// An empty line
or Ctrl-Z terminates the program </span></p>

<p><span>} </span></p>

<p><span>} ///:~ </span></p>

<p><span>The reason for the
exception specification is that <b>readLine( ) </b>can throw an <b>IOException</b>.
Note that <b>System.in </b>should usually be buffered, as with most streams. </span></p>

<p><b><span>Exercise 21: </span></b><span>(1) Write a program that
takes standard input and capitalizes all characters, then puts the results on
standard output. Redirect the contents of a file into this program (the process
of redirection will vary depending on your operating system). </span></p>

<p><span>Changing <b>System.out
</b>to a </span></p>

<p><b><span>PrintWriter </span></b></p>

<p><b><span>System.out </span></b><span>is a <b>PrintStream</b>,
which is an <b>OutputStream</b>. <b>PrintWriter </b>has a constructor that
takes an <b>OutputStream </b>as an argument. Thus, if you want, you can convert
<b>System.out </b>into a <b>PrintWriter </b>using that constructor: </span></p>

<p><span>//:
io/ChangeSystemOut.java </span></p>

<p><span>// Turn
System.out into a PrintWriter. </span></p>

<p><span>import java.io.*;
</span></p>

<p><span>public class
ChangeSystemOut { </span></p>

<p><span>public static
void main(String[] args) { </span></p>

<p><span>PrintWriter out
= new PrintWriter(System.out, true); </span></p>

<p><span>out.println(&quot;Hello,
world&quot;); </span></p>

<p><span>} </span></p>

<p><span>} /* Output: </span></p>

<p><span>Hello, world </span></p>

<p><span>*///:~ </span></p>

<p><span>It's important to use the
two-argument version of the <b>PrintWriter </b>constructor and to set the
second argument to <b>true </b>in order to enable automatic flushing;
otherwise, you may not see the output. </span></p>

<p><span>Redirecting standard
I/O </span></p>

<p><span>The Java <b>System </b>class
allows you to redirect the standard input, output, and error I/O streams using
simple <b>static </b>method calls: </span></p>

<p><b><span>setIn(InputStream) </span></b></p>

<p><b><span>setOut(PrintStream) </span></b></p>

<p><b><span>setErr(PrintStream) </span></b></p>

<p><span>Redirecting output is
especially useful if you suddenly start creating a large amount of output on
your screen, and it's scrolling past faster than you can read it.</span><span>4 </span><span>Redirecting input is
valuable for a command-line program in which you want to test a particular
user-input sequence repeatedly. Here's a simple example that shows the use of
these methods: </span></p>

<p><span>//:
io/Redirecting.java </span></p>

<p><span>// Demonstrates
standard I/O redirection. </span></p>

<p><span>import
java.io.*; </span></p>

<p><span>public class
Redirecting { </span></p>

<p><span>public static
void main(String[] args) </span></p>

<p><span>throws
IOException { </span></p>

<p><span>PrintStream
console = System.out; </span></p>

<p><span>BufferedInputStream
in = new BufferedInputStream( </span></p>

<p><span>new
FileInputStream(&quot;Redirecting.java&quot;)); </span></p>

<p><span>PrintStream out
= new PrintStream( </span></p>

<p><span>new
BufferedOutputStream( </span></p>

<p><span>new
FileOutputStream(&quot;test.out&quot;))); </span></p>

<p><span>System.setIn(in);
</span></p>

<p><span>System.setOut(out);
</span></p>

<p><span>System.setErr(out);
</span></p>

<p><span>BufferedReader
br = new BufferedReader( </span></p>

<p><span>new
InputStreamReader(System.in)); </span></p>

<p><span>String s; </span></p>

<p><span>while((s =
br.readLine()) != null) </span></p>

<p><span>System.out.println(s);
</span></p>

<p><span>out.close(); //
Remember this! </span></p>

<p><span>System.setOut(console);
</span></p>

<p><span>} </span></p>

<p><span>} ///:~ </span></p>

<p><span>This program attaches
standard input to a file and redirects standard output and standard error to
another file. Notice that it stores a reference to the original <b>System.out </b>object
at the beginning of the program, and restores the system output to that object
at the end. </span></p>

<p><span>I/O redirection
manipulates streams of bytes, not streams of characters; thus, <b>InputStreams </b>and
<b>OutputStreams </b>are used rather than <b>Reader</b>s and <b>Writer</b>s. </span></p>

<p><span>Process control </span></p>

<p><span>You will often need to
execute other operating system programs from inside Java, and to control the
input and output from such programs. The Java library provides classes to
perform such operations. </span></p>

<p><span>A common task is to run a
program and send the resulting output to the console. This section contains a
utility to simplify this task. </span></p>

<p><span>Two types of errors can
occur with this utility: the normal errors that result in exceptionsfor these
we will just rethrow a runtime exceptionand errors from the execution of the
process itself. We want to report these errors with a separate exception: </span></p>

<p><span>//:
net/mindview/util/OSExecuteException.java </span></p>

<p><span>package
net.mindview.util; </span></p>

<p><span>public class
OSExecuteException extends RuntimeException { </span></p>

<p><span>public
OSExecuteException(String why) { super(why); } </span></p>

<p><span>} ///:~ </span></p>

<p><span>To run a program, you pass
<b>OSExecute.command( ) </b>a <b>command </b>string, which is the same command
that you would type to run the program on the console. This command is passed
to the <b>java.lang.ProcessBuilder </b>constructor (which requires it as a
sequence of <b>String </b>objects), and the resulting <b>ProcessBuilder </b>object
is started: </span></p>

<p><span>//:
net/mindview/util/OSExecute.java </span></p>

<p><span>// Run an
operating system command </span></p>

<p><i><span>I/O
677 </span></i></p>

<p><span>//
and send the output to the console. </span></p>

<p><span>package
net.mindview.util; </span></p>

<p><span>import
java.io.*; </span></p>

<p><span>public class
OSExecute { </span></p>

<p><span>public static
void command(String command) { </span></p>

<p><span>boolean err =
false; </span></p>

<p><span>try { </span></p>

<p><span>Process process
= </span></p>

<p><span>new
ProcessBuilder(command.split(&quot; &quot;)).start(); </span></p>

<p><span>BufferedReader
results = new BufferedReader( </span></p>

<p><span>new
InputStreamReader(process.getInputStream())); </span></p>

<p><span>String s; </span></p>

<p><span>while((s =
results.readLine())!= null) </span></p>

<p><span>System.out.println(s);
</span></p>

<p><span>BufferedReader
errors = new BufferedReader( </span></p>

<p><span>new
InputStreamReader(process.getErrorStream())); </span></p>

<p><span>// Report errors
and return nonzero value </span></p>

<p><span>// to calling
process if there are problems: </span></p>

<p><span>while((s =
errors.readLine())!= null) { </span></p>

<p><span>System.err.println(s);
</span></p>

<p><span>err = true; </span></p>

<p><span>} </span></p>

<p><span>}
catch(Exception e) { </span></p>

<p><span>// Compensate
for Windows 2000, which throws an </span></p>

<p><span>// exception for
the default command line: </span></p>

<p><span>if(!command.startsWith(&quot;CMD
/C&quot;)) </span></p>

<p><span>command(&quot;CMD
/C &quot; + command); </span></p>

<p><span>else </span></p>

<p><span>throw new
RuntimeException(e); </span></p>

<p><span>} </span></p>

<p><span>if(err) </span></p>

<p><span>throw new
OSExecuteException(&quot;Errors executing &quot; + </span></p>

<p><span>command); </span></p>

<p><span>} </span></p>

<p><span>} ///:~ </span></p>

<p><span>To capture the standard
output stream from the program as it executes, you call <b>getInputStream( )</b>.
This is because an <b>InputStream </b>is something we can read from. </span></p>

<p><span>The results from the
program arrive a line at a time, so they are read using <b>readLine( )</b>.
Here the lines are simply printed, but you may also want to capture and return
them from <b>command( )</b>. </span></p>

<p><span>The program's errors are
sent to the standard error stream, and are captured by calling <b>getErrorStream(
)</b>. If there are any errors, they are printed and an <b>OSExecuteException </b>is
thrown so the calling program will handle the problem. </span></p>

<p><span>Here's an example that
shows how to use <b>OSExecute: </b></span></p>

<p><span>//:
io/OSExecuteDemo.java </span></p>

<p><span>// Demonstrates
standard I/O redirection. </span></p>

<p><span>import
net.mindview.util.*; </span></p>

<p><span>public class
OSExecuteDemo { </span></p>

<p><span>public static
void main(String[] args) { </span></p>

<p><span>OSExecute.command(&quot;javap
OSExecuteDemo&quot;); </span></p>

<p><span>} </span></p>

<p><span>} /* Output: </span></p>

<p><span>Compiled from
&quot;OSExecuteDemo.java&quot; </span></p>

<p><span>public class
OSExecuteDemo extends java.lang.Object{ </span></p>

<p><i><span>678
Thinking in Java Bruce Eckel </span></i></p>

<p><span>public
OSExecuteDemo(); </span></p>

<p><span>public static
void main(java.lang.String[]); </span></p>

<p><span>} </span></p>

<p><span>*///:~ </span></p>

<p><span>This uses the <b>javap </b>decompiler
(that comes with the JDK) to decompile the program. </span></p>

<p><b><span>Exercise 22: </span></b><span>(5) Modify <b>OSExecute.java
</b>so that, instead of printing the standard output stream, it returns the
results of executing the program as a <b>List </b>of <b>String</b>s. Demonstrate
the use of this new version of the utility. </span></p>

<p><span>New I/O </span></p>

<p><span>The Java &quot;new&quot;
I/O library, introduced in JDK 1.4 in the <b>java.nio.* </b>packages, has one
goal: speed. In fact, the &quot;old&quot; I/O packages have been reimplemented
using <b>nio </b>in order to take advantage of this speed increase, so you will
benefit even if you don't explicitly write code with <b>nio</b>. The speed
increase occurs both in file I/O, which is explored here, and in network I/O,
which is covered in <i>Thinking in Enterprise Java</i>. </span></p>

<p><span>The speed comes from using
structures that are closer to the operating system's way of performing I/O: <i>channels
</i>and <i>buffers</i>. You could think of it as a coal mine; the channel is
the mine containing the seam of coal (the data), and the buffer is the cart
that you send into the mine. The cart comes back full of coal, and you get the
coal from the cart. That is, you don't interact directly with the channel; you
interact with the buffer and send the buffer into the channel. The channel
either pulls data from the buffer, or puts data into the buffer. </span></p>

<p><span>The only kind of buffer
that communicates directly with a channel is a <b>ByteBuffer</b>that is, a
buffer that holds raw bytes. If you look at the JDK documentation for <b>java.nio.ByteBuffer</b>,
you'll see that it's fairly basic: You create one by telling it how much
storage to allocate, and there are methods to put and get data, in either raw
byte form or as primitive data types. But there's no way to put or get an
object, or even a <b>String</b>. It's fairly low-level, precisely because this
makes a more efficient mapping with most operating systems. </span></p>

<p><span>Three of the classes in
the &quot;old&quot; I/O have been modified so that they produce a <b>FileChannel:
FileInputStream</b>, <b>FileOutputStream</b>, and, for both reading and
writing, <b>RandomAccessFile</b>. Notice that these are the byte manipulation
streams, in keeping with the low-level nature of <b>nio</b>. The <b>Reader </b>and
<b>Writer </b>character-mode classes do not produce channels, but the <b>java.nio.channels.Channels
</b>class has utility methods to produce <b>Reader</b>s and <b>Writer</b>s from
channels. </span></p>

<p><span>Here's a simple example
that exercises all three types of stream to produce channels that are
writeable, read/writeable, and readable: </span></p>

<p><span>//:
io/GetChannel.java </span></p>

<p><span>// Getting
channels from streams </span></p>

<p><span>import
java.nio.*; </span></p>

<p><span>import
java.nio.channels.*; </span></p>

<p><span>import
java.io.*; </span></p>

<p><span>public class
GetChannel { </span></p>

<p><span>private static
final int BSIZE = 1024; </span></p>

<p><span>public static
void main(String[] args) throws Exception { </span></p>

<p><span>// Write a file:
</span></p>

<p><span>FileChannel fc =
</span></p>

<p><span>new
FileOutputStream(&quot;data.txt&quot;).getChannel(); </span></p>

<p><span>fc.write(ByteBuffer.wrap(&quot;Some
text &quot;.getBytes())); </span></p>

<p><i><span>I/O
679 </span></i></p>

<p><span>fc.close();
</span></p>

<p><span>// Add to the
end of the file: </span></p>

<p><span>fc = </span></p>

<p><span>new
RandomAccessFile(&quot;data.txt&quot;, &quot;rw&quot;).getChannel(); </span></p>

<p><span>fc.position(fc.size());
// Move to the end </span></p>

<p><span>fc.write(ByteBuffer.wrap(&quot;Some
more&quot;.getBytes())); </span></p>

<p><span>fc.close(); </span></p>

<p><span>// Read the
file: </span></p>

<p><span>fc = new FileInputStream(&quot;data.txt&quot;).getChannel();
</span></p>

<p><span>ByteBuffer buff
= ByteBuffer.allocate(BSIZE); </span></p>

<p><span>fc.read(buff); </span></p>

<p><span>buff.flip(); </span></p>

<p><span>while(buff.hasRemaining())
</span></p>

<p><span>System.out.print((char)buff.get());
</span></p>

<p><span>} </span></p>

<p><span>} /* Output: </span></p>

<p><span>Some text Some
more </span></p>

<p><span>*///:~ </span></p>

<p><span>For any of the stream
classes shown here, <b>getChannel( ) </b>will produce a <b>FileChannel</b>. A
channel is fairly basic: You can hand it a <b>ByteBuffer </b>for reading or
writing, and you can lock regions of the file for exclusive access (this will
be described later). </span></p>

<p><span>One way to put bytes into
a <b>ByteBuffer </b>is to stuff them in directly using one of the
&quot;put&quot; methods, to put one or more bytes, or values of primitive
types. However, as seen here, you can also &quot;wrap&quot; an existing <b>byte
</b>array in a <b>ByteBuffer </b>using the <b>wrap( ) </b>method. When you do
this, the underlying array is not copied, but instead is used as the storage
for the generated <b>ByteBuffer</b>. We say that the <b>ByteBuffer </b>is
&quot;backed by&quot; the array. </span></p>

<p><span>The <b>data.txt </b>file
is reopened using a <b>RandomAccessFile</b>. Notice that you can move the <b>FileChannel
</b>around in the file; here, it is moved to the end so that additional writes
will be appended. </span></p>

<p><span>For read-only access, you
must explicitly allocate a <b>ByteBuffer </b>using the <b>static allocate( ) </b>method.
The goal of <b>nio </b>is to rapidly move large amounts of data, so the size of
the <b>ByteBuffer </b>should be significantin fact, the lK used here is
probably quite a bit smaller than you'd normally want to use (you'll have to
experiment with your working application to find the best size). </span></p>

<p><span>It's also possible to go
for even more speed by using <b>allocateDirect( ) </b>instead of <b>allocate( )
</b>to produce a &quot;direct&quot; buffer that may have an even higher
coupling with the operating system. However, the overhead in such an allocation
is greater, and the actual implementation varies from one operating system to
another, so again, you must experiment with your working application to
discover whether direct buffers will buy you any advantage in speed. </span></p>

<p><span>Once you call <b>read( ) </b>to
tell the <b>FileChannel </b>to store bytes into the <b>ByteBuffer</b>, you must
call <b>flip( ) </b>on the buffer to tell it to get ready to have its bytes extracted
(yes, this seems a bit crude, but remember that it's very low-level and is done
for maximum speed). And if we were to use the buffer for further <b>read( ) </b>operations,
we'd also have to call <b>clear( ) </b>to prepare it for each <b>read( )</b>.
You can see this in a simple file-copying program: </span></p>

<p><span>//:
io/ChannelCopy.java </span></p>

<p><span>// Copying a
file using channels and buffers </span></p>

<p><span>// {Args:
ChannelCopy.java test.txt} </span></p>

<p><span>import
java.nio.*; </span></p>

<p><span>import
java.nio.channels.*; </span></p>

<p><span>import
java.io.*; </span></p>

<p><span>public class
ChannelCopy { </span></p>

<p><i><span>680
Thinking in Java Bruce Eckel </span></i></p>

<p><span>private
static final int BSIZE = 1024; </span></p>

<p><span>public static
void main(String[] args) throws Exception { </span></p>

<p><span>if(args.length
!= 2) { </span></p>

<p><span>System.out.println(&quot;arguments:
sourcefile destfile&quot;); </span></p>

<p><span>System.exit(1); </span></p>

<p><span>} </span></p>

<p><span>FileChannel </span></p>

<p><span>in = new
FileInputStream(args[0]).getChannel(), </span></p>

<p><span>out = new
FileOutputStream(args[1]).getChannel(); </span></p>

<p><span>ByteBuffer
buffer = ByteBuffer.allocate(BSIZE); </span></p>

<p><span>while(in.read(buffer)
!= -1) { </span></p>

<p><span>buffer.flip();
// Prepare for writing </span></p>

<p><span>out.write(buffer);
</span></p>

<p><span>buffer.clear();
// Prepare for reading </span></p>

<p><span>} </span></p>

<p><span>} </span></p>

<p><span>} ///:~ </span></p>

<p><span>You can see that one <b>FileChannel
</b>is opened for reading, and one for writing. A <b>ByteBuffer </b>is
allocated, and when <b>FileChannel.read( ) </b>returns <b>-1 </b>(a holdover,
no doubt, from Unix and C), it means that you've reached the end of the input.
After each <b>read( )</b>, which puts data into the buffer, <b>flip( ) </b>prepares
the buffer so that its information can be extracted by the <b>write( )</b>.
After the <b>write( )</b>, the information is still in the buffer, and <b>clear(
) </b>resets all the internal pointers so that it's ready to accept data during
another <b>read( )</b>. </span></p>

<p><span>The preceding program is
not the ideal way to handle this kind of operation, however. Special methods <b>transferTo(
) </b>and <b>transferFrom( ) </b>allow you to connect one channel directly to
another: </span></p>

<p><span>//:
io/TransferTo.java </span></p>

<p><span>// Using
transferTo() between channels </span></p>

<p><span>// {Args:
TransferTo.java TransferTo.txt} </span></p>

<p><span>import
java.nio.channels.*; </span></p>

<p><span>import
java.io.*; </span></p>

<p><span>public class
TransferTo { </span></p>

<p><span>public static
void main(String[] args) throws Exception { </span></p>

<p><span>if(args.length
!= 2) { </span></p>

<p><span>System.out.println(&quot;arguments:
sourcefile destfile&quot;); </span></p>

<p><span>System.exit(1); </span></p>

<p><span>} </span></p>

<p><span>FileChannel </span></p>

<p><span>in = new
FileInputStream(args[0]).getChannel(), </span></p>

<p><span>out = new
FileOutputStream(args[1]).getChannel(); </span></p>

<p><span>in.transferTo(0,
in.size(), out); </span></p>

<p><span>// Or: </span></p>

<p><span>//
out.transferFrom(in, 0, in.size()); </span></p>

<p><span>} </span></p>

<p><span>} ///:~ </span></p>

<p><span>You won't do this kind of
thing very often, but it's good to know about. </span></p>

<p><span>Converting data </span></p>

<p><span>If you look back at <b>GetChannel.java</b>,
you'll notice that, to print the information in the file, we are pulling the
data out one <b>byte </b>at a time and casting each <b>byte </b>to a <b>char</b>.
This seems a bit primitiveif you look at the <b>java.nio.CharBuffer </b>class,
you'll see that it has a <b>toString( ) </b>method that says, &quot;Returns a
string containing the characters in this buffer.&quot; Since a <b>ByteBuffer </b>can
be viewed as a <b>CharBuffer </b>with the <b>asCharBuffer( ) </b>method, </span></p>

<p><i><span>I/O
681 </span></i></p>

<p><span>why not use
that? As you can see from the first line in the output statement below, this
doesn't work out: </span></p>

<p><span>//:
io/BufferToText.java </span></p>

<p><span>// Converting text
to and from ByteBuffers </span></p>

<p><span>import
java.nio.*; </span></p>

<p><span>import java.nio.channels.*;
</span></p>

<p><span>import
java.nio.charset.*; </span></p>

<p><span>import
java.io.*; </span></p>

<p><span>public class
BufferToText { </span></p>

<p><span>private static
final int BSIZE = 1024; </span></p>

<p><span>public static
void main(String[] args) throws Exception { </span></p>

<p><span>FileChannel fc =
</span></p>

<p><span>new
FileOutputStream(&quot;data2.txt&quot;).getChannel(); </span></p>

<p><span>fc.write(ByteBuffer.wrap(&quot;Some
text&quot;.getBytes())); </span></p>

<p><span>fc.close(); </span></p>

<p><span>fc = new
FileInputStream(&quot;data2.txt&quot;).getChannel(); </span></p>

<p><span>ByteBuffer buff
= ByteBuffer.allocate(BSIZE); </span></p>

<p><span>fc.read(buff); </span></p>

<p><span>buff.flip(); </span></p>

<p><span>// Doesn</span><span>'</span><span>t work: </span></p>

<p><span>System.out.println(buff.asCharBuffer());
</span></p>

<p><span>// Decode using
this system</span><span>'</span><span>s default Charset: </span></p>

<p><span>buff.rewind(); </span></p>

<p><span>String encoding
= System.getProperty(&quot;file.encoding&quot;); </span></p>

<p><span>System.out.println(&quot;Decoded
using &quot; + encoding + &quot;: &quot; </span></p>

<p><span>+
Charset.forName(encoding).decode(buff)); </span></p>

<p><span>// Or, we could
encode with something that will print: </span></p>

<p><span>fc = new
FileOutputStream(&quot;data2.txt&quot;).getChannel(); </span></p>

<p><span>fc.write(ByteBuffer.wrap(
</span></p>

<p><span>&quot;Some
text&quot;.getBytes(&quot;UTF-16BE&quot;))); </span></p>

<p><span>fc.close(); </span></p>

<p><span>// Now try
reading again: </span></p>

<p><span>fc = new
FileInputStream(&quot;data2.txt&quot;).getChannel(); </span></p>

<p><span>buff.clear(); </span></p>

<p><span>fc.read(buff); </span></p>

<p><span>buff.flip(); </span></p>

<p><span>System.out.println(buff.asCharBuffer());
</span></p>

<p><span>// Use a
CharBuffer to write through: </span></p>

<p><span>fc = new
FileOutputStream(&quot;data2.txt&quot;).getChannel(); </span></p>

<p><span>buff =
ByteBuffer.allocate(24); // More than needed </span></p>

<p><span>buff.asCharBuffer().put(&quot;Some
text&quot;); </span></p>

<p><span>fc.write(buff); </span></p>

<p><span>fc.close(); </span></p>

<p><span>// Read and
display: </span></p>

<p><span>fc = new
FileInputStream(&quot;data2.txt&quot;).getChannel(); </span></p>

<p><span>buff.clear(); </span></p>

<p><span>fc.read(buff); </span></p>

<p><span>buff.flip(); </span></p>

<p><span>System.out.println(buff.asCharBuffer());
</span></p>

<p><span>} </span></p>

<p><span>} /* Output: </span></p>

<p><span>???? </span></p>

<p><span>Decoded using
Cp1252: Some text </span></p>

<p><span>Some text </span></p>

<p><span>Some text </span></p>

<p><span>*///:~ </span></p>

<p><span>The buffer contains plain
bytes, and to turn these into characters, we must either <i>encode </i>them as
we put them in (so that they will be meaningful when they come out) or <i>decode
</i>them as they come out of the buffer. This can be accomplished using the </span></p>

<p><i><span>682
Thinking in Java Bruce Eckel </span></i></p>

<p><b><span>java.nio.charset.Charset
</span></b><span>class,
which provides tools for encoding into many different types of character sets: </span></p>

<p><span>//:
io/AvailableCharSets.java </span></p>

<p><span>// Displays Charsets
and aliases </span></p>

<p><span>import
java.nio.charset.*; </span></p>

<p><span>import
java.util.*; </span></p>

<p><span>import static
net.mindview.util.Print.*; </span></p>

<p><span>public class
AvailableCharSets { </span></p>

<p><span>public static
void main(String[] args) { </span></p>

<p><span>SortedMap&lt;String,Charset&gt;
charSets = </span></p>

<p><span>Charset.availableCharsets();
</span></p>

<p><span>Iterator&lt;String&gt;
it = charSets.keySet().iterator(); </span></p>

<p><span>while(it.hasNext())
{ </span></p>

<p><span>String csName =
it.next(); </span></p>

<p><span>printnb(csName);
</span></p>

<p><span>Iterator aliases
= </span></p>

<p><span>charSets.get(csName).aliases().iterator();
</span></p>

<p><span>if(aliases.hasNext())
</span></p>

<p><span>printnb(&quot;:
&quot;); </span></p>

<p><span>while(aliases.hasNext())
{ </span></p>

<p><span>printnb(aliases.next());
</span></p>

<p><span>if(aliases.hasNext())
</span></p>

<p><span>printnb(&quot;,
&quot;); </span></p>

<p><span>} </span></p>

<p><span>print(); </span></p>

<p><span>} </span></p>

<p><span>} </span></p>

<p><span>} /* Output: </span></p>

<p><span>Big5: csBig5 </span></p>

<p><span>Big5-HKSCS:
big5-hkscs, big5hk, big5-hkscs:unicode3.0, big5hkscs, Big5_HKSCS </span></p>

<p><span>EUC-JP: eucjis,
x-eucjp, csEUCPkdFmtjapanese, eucjp, Extended_UNIX_Code_Packed_Format_for_Japanese,
x-euc-jp, euc_jp </span></p>

<p><span>EUC-KR: ksc5601,
5601, ksc5601_1987, ksc_5601, ksc5601-1987, euc_kr, ks_c_5601-1987, euckr,
csEUCKR </span></p>

<p><span>GB18030:
gb18030-2000 </span></p>

<p><span>GB2312:
gb2312-1980, gb2312, EUC_CN, gb2312-80, euc-cn, euccn, x-EUC-CN </span></p>

<p><span>GBK: windows-936,
CP936 </span></p>

<p><span>... </span></p>

<p><span>*///:~ </span></p>

<p><span>So, returning to <b>BufferToText.java</b>,
if you <b>rewind( ) </b>the buffer (to go back to the beginning of the data)
and then use that platform's default character set to <b>decode( ) </b>the
data, the resulting <b>CharBuffer </b>will print to the console just fine. To
discover the default character set, use <b>System.getProperty(file.encoding&quot;)</b>,
which produces the string that names the character set. Passing this to <b>Charset.forName(
) </b>produces the <b>Charset </b>object that can be used to decode the string.
</span></p>

<p><span>Another alternative is to <b>encode(
) </b>using a character set that will result in something printable when the
file is read, as you see in the third part of <b>BufferToText.java</b>. Here,
UTF-16BE is used to write the text into the file, and when it is read, all you
must do is convert it to a <b>CharBuffer</b>, and it produces the expected
text. </span></p>

<p><span>Finally, you see what
happens if you <i>write </i>to the <b>ByteBuffer </b>through a <b>CharBuffer </b>(you'll
learn more about this later). Note that 24 bytes are allocated for the <b>ByteBuffer</b>.
Since each <b>char </b>requires two bytes, this is enough for 12 <b>char</b>s,
but &quot;Some text&quot; only has 9. The remaining zero bytes still appear in
the representation of the <b>CharBuffer </b>produced by its <b>toString( )</b>,
as you can see in the output. </span></p>

<p><i><span>I/O
683 </span></i></p>

<p><b><span>Exercise
23: </span></b><span>(6)
Create and test a utility method to print the contents of a <b>CharBuffer </b>up
to the point where the characters are no longer printable. </span></p>

<p><span>Fetching primitives </span></p>

<p><span>Although a <b>ByteBuffer </b>only
holds bytes, it contains methods to produce each of the different types of
primitive values from the bytes it contains. This example shows the insertion
and extraction of various values using these methods: </span></p>

<p><span>//:
io/GetData.java </span></p>

<p><span>// Getting
different representations from a ByteBuffer </span></p>

<p><span>import
java.nio.*; </span></p>

<p><span>import static
net.mindview.util.Print.*; </span></p>

<p><span>public class
GetData { </span></p>

<p><span>private static
final int BSIZE = 1024; </span></p>

<p><span>public static
void main(String[] args) { </span></p>

<p><span>ByteBuffer bb =
ByteBuffer.allocate(BSIZE); </span></p>

<p><span>// Allocation
automatically zeroes the ByteBuffer: </span></p>

<p><span>int i = 0; </span></p>

<p><span>while(i++ &lt;
bb.limit()) </span></p>

<p><span>if(bb.get() !=
0) </span></p>

<p><span>print(&quot;nonzero&quot;);
</span></p>

<p><span>print(&quot;i =
&quot; + i); </span></p>

<p><span>bb.rewind(); </span></p>

<p><span>// Store and
read a char array: </span></p>

<p><span>bb.asCharBuffer().put(&quot;Howdy!&quot;);
</span></p>

<p><span>char c; </span></p>

<p><span>while((c =
bb.getChar()) != 0) </span></p>

<p><span>printnb(c +
&quot; &quot;); </span></p>

<p><span>print(); </span></p>

<p><span>bb.rewind(); </span></p>

<p><span>// Store and
read a short: </span></p>

<p><span>bb.asShortBuffer().put((short)471142);
</span></p>

<p><span>print(bb.getShort());
</span></p>

<p><span>bb.rewind(); </span></p>

<p><span>// Store and
read an int: </span></p>

<p><span>bb.asIntBuffer().put(99471142);
</span></p>

<p><span>print(bb.getInt());
</span></p>

<p><span>bb.rewind(); </span></p>

<p><span>// Store and
read a long: </span></p>

<p><span>bb.asLongBuffer().put(99471142);
</span></p>

<p><span>print(bb.getLong());
</span></p>

<p><span>bb.rewind(); </span></p>

<p><span>// Store and
read a float: </span></p>

<p><span>bb.asFloatBuffer().put(99471142);
</span></p>

<p><span>print(bb.getFloat());
</span></p>

<p><span>bb.rewind(); </span></p>

<p><span>// Store and
read a double: </span></p>

<p><span>bb.asDoubleBuffer().put(99471142);
</span></p>

<p><span>print(bb.getDouble());
</span></p>

<p><span>bb.rewind(); </span></p>

<p><span>} </span></p>

<p><span>} /* Output: </span></p>

<p><span>i = 1025 </span></p>

<p><span>H o w d y ! </span></p>

<p><span>12390 </span></p>

<p><span>99471142 </span></p>

<p><span>99471142 </span></p>

<p><span>9.9471144E7 </span></p>

<p><span>9.9471142E7 </span></p>

<p><i><span>684
Thinking in Java Bruce Eckel </span></i></p>

<p><span>*///:~
</span></p>

<p><span>After a <b>ByteBuffer </b>is
allocated, its values are checked to see whether buffer allocation
automatically zeroes the contentsand it does. All 1.024 values are checked (up
to the <b>limit( ) </b>of the buffer), and all are zero. </span></p>

<p><span>The easiest way to insert
primitive values into a <b>ByteBuffer </b>is to get the appropriate
&quot;view&quot; on that buffer using <b>asCharBuffer( )</b>, <b>asShortBuffer(
)</b>, etc., and then to use that view's <b>put( ) </b>method. You can see this
is the process used for each of the primitive data types. The only one of these
that is a little odd is the <b>put( ) </b>for the <b>ShortBuffer</b>, which
requires a cast (note that the cast truncates and changes the resulting value).
All the other view buffers do not require casting in their <b>put( ) </b>methods.
</span></p>

<p><span>View buffers </span></p>

<p><span>A &quot;view buffer&quot;
allows you to look at an underlying <b>ByteBuffer </b>through the window of a
particular primitive type. The <b>ByteBuffer </b>is still the actual storage
that's &quot;backing&quot; the view, so any changes you make to the view are
reflected in modifications to the data in the <b>ByteBuffer</b>. As seen in the
previous example, this allows you to conveniently insert primitive types into a
<b>ByteBuffer</b>. A view also allows you to read primitive values from a <b>ByteBuffer</b>,
either one at a time (as <b>ByteBuffer </b>allows) or in batches (into arrays).
Here's an example that manipulates <b>ints </b>in a <b>ByteBuffer </b>via an <b>IntBuffer:
</b></span></p>

<p><span>//:
io/IntBufferDemo.java </span></p>

<p><span>// Manipulating
ints in a ByteBuffer with an IntBuffer </span></p>

<p><span>import
java.nio.*; </span></p>

<p><span>public class
IntBufferDemo { </span></p>

<p><span>private static
final int BSIZE = 1024; </span></p>

<p><span>public static
void main(String[] args) { </span></p>

<p><span>ByteBuffer bb =
ByteBuffer.allocate(BSIZE); </span></p>

<p><span>IntBuffer ib =
bb.asIntBuffer(); </span></p>

<p><span>// Store an
array of int: </span></p>

<p><span>ib.put(new
int[]{ 11, 42, 47, 99, 143, 811, 1016 }); </span></p>

<p><span>// Absolute
location read and write: </span></p>

<p><span>System.out.println(ib.get(3));
</span></p>

<p><span>ib.put(3, 1811);
</span></p>

<p><span>// Setting a new
limit before rewinding the buffer. </span></p>

<p><span>ib.flip(); </span></p>

<p><span>while(ib.hasRemaining())
{ </span></p>

<p><span>int i =
ib.get(); </span></p>

<p><span>System.out.println(i);
</span></p>

<p><span>} </span></p>

<p><span>} </span></p>

<p><span>} /* Output: </span></p>

<p><span>99 </span></p>

<p><span>11 </span></p>

<p><span>42 </span></p>

<p><span>47 </span></p>

<p><span>1811 </span></p>

<p><span>143 </span></p>

<p><span>811 </span></p>

<p><span>1016 </span></p>

<p><span>*///:~ </span></p>

<p><span>The overloaded <b>put( ) </b>method
is first used to store an array of <b>int</b>. The following <b>get( ) </b>and <b>put(
) </b>method calls directly access an <b>int </b>location in the underlying <b>ByteBuffer</b>.
Note that these absolute location accesses are available for primitive types by
talking directly to a <b>ByteBuffer</b>, as well. </span></p>

<p><i><span>I/O
685 </span></i></p>

<p><span>Once the
underlying <b>ByteBuffer </b>is filled with <b>int</b>s or some other primitive
type via a view buffer, then that <b>ByteBuffer </b>can be written directly to
a channel. You can just as easily read from a channel and use a view buffer to
convert everything to a particular type of primitive. Here's an example that
interprets the same sequence of bytes as <b>short</b>, <b>int</b>, <b>float</b>,
<b>long</b>, and <b>double </b>by producing different view buffers on the same <b>ByteBuffer</b>:
</span></p>

<p><span>//: io/ViewBuffers.java
</span></p>

<p><span>import
java.nio.*; </span></p>

<p><span>import static
net.mindview.util.Print.*; </span></p>

<p><span>public class
ViewBuffers { </span></p>

<p><span>public static
void main(String[] args) { </span></p>

<p><span>ByteBuffer bb =
ByteBuffer.wrap( </span></p>

<p><span>new byte[]{ 0,
0, 0, 0, 0, 0, 0, </span><span></span><span>a</span><span>'</span><span> }); </span></p>

<p><span>bb.rewind(); </span></p>

<p><span>printnb(&quot;Byte
Buffer &quot;); </span></p>

<p><span>while(bb.hasRemaining())
</span></p>

<p><span>printnb(bb.position()+
&quot; -&gt; &quot; + bb.get() + &quot;, &quot;); </span></p>

<p><span>print(); </span></p>

<p><span>CharBuffer cb = </span></p>

<p><span>((ByteBuffer)bb.rewind()).asCharBuffer();
</span></p>

<p><span>printnb(&quot;Char
Buffer &quot;); </span></p>

<p><span>while(cb.hasRemaining())
</span></p>

<p><span>printnb(cb.position()
+ &quot; -&gt; &quot; + cb.get() + &quot;, &quot;); </span></p>

<p><span>print(); </span></p>

<p><span>FloatBuffer fb =
</span></p>

<p><span>((ByteBuffer)bb.rewind()).asFloatBuffer();
</span></p>

<p><span>printnb(&quot;Float
Buffer &quot;); </span></p>

<p><span>while(fb.hasRemaining())
</span></p>

<p><span>printnb(fb.position()+
&quot; -&gt; &quot; + fb.get() + &quot;, &quot;); </span></p>

<p><span>print(); </span></p>

<p><span>IntBuffer ib = </span></p>

<p><span>((ByteBuffer)bb.rewind()).asIntBuffer();
</span></p>

<p><span>printnb(&quot;Int
Buffer &quot;); </span></p>

<p><span>while(ib.hasRemaining())
</span></p>

<p><span>printnb(ib.position()+
&quot; -&gt; &quot; + ib.get() + &quot;, &quot;); </span></p>

<p><span>print(); </span></p>

<p><span>LongBuffer lb = </span></p>

<p><span>((ByteBuffer)bb.rewind()).asLongBuffer();
</span></p>

<p><span>printnb(&quot;Long
Buffer &quot;); </span></p>

<p><span>while(lb.hasRemaining())
</span></p>

<p><span>printnb(lb.position()+
&quot; -&gt; &quot; + lb.get() + &quot;, &quot;); </span></p>

<p><span>print(); </span></p>

<p><span>ShortBuffer sb =
</span></p>

<p><span>((ByteBuffer)bb.rewind()).asShortBuffer();
</span></p>

<p><span>printnb(&quot;Short
Buffer &quot;); </span></p>

<p><span>while(sb.hasRemaining())
</span></p>

<p><span>printnb(sb.position()+
&quot; -&gt; &quot; + sb.get() + &quot;, &quot;); </span></p>

<p><span>print(); </span></p>

<p><span>DoubleBuffer db
= </span></p>

<p><span>((ByteBuffer)bb.rewind()).asDoubleBuffer();
</span></p>

<p><span>printnb(&quot;Double
Buffer &quot;); </span></p>

<p><span>while(db.hasRemaining())
</span></p>

<p><span>printnb(db.position()+
&quot; -&gt; &quot; + db.get() + &quot;, &quot;); </span></p>

<p><span>} </span></p>

<p><span>} /* Output: </span></p>

<p><span>Byte Buffer 0
-&gt; 0, 1 -&gt; 0, 2 -&gt; 0, 3 -&gt; 0, 4 -&gt; 0, 5 -&gt; 0, 6 -&gt; 0, 7
-&gt; 97, </span></p>

<p><span>Char Buffer 0
-&gt; , 1 -&gt; , 2 -&gt; , 3 -&gt; a, </span></p>

<p><span>Float Buffer 0
-&gt; 0.0, 1 -&gt; 1.36E-43, </span></p>

<p><span>Int Buffer 0
-&gt; 0, 1 -&gt; 97, </span></p>

<p><span>Long Buffer 0
-&gt; 97, </span></p>

<p><i><span>686
Thinking in Java Bruce Eckel </span></i></p>

<p><span>Short
Buffer 0 -&gt; 0, 1 -&gt; 0, 2 -&gt; 0, 3 -&gt; 97, </span></p>

<p><span>Double Buffer 0
-&gt; 4.8E-322, </span></p>

<p><span>*///:~ </span></p>

<p><span>The <b>ByteBuffer </b>is
produced by &quot;wrapping&quot; an eight-<b>byte </b>array, which is then
displayed via view buffers of all the different primitive types. You can see in
the following diagram the way the data appears differently when read from the
different types of buffers: </span></p>

<p><span>This corresponds to the
output from the program. </span></p>

<p><b><span>Exercise 24: </span></b><span>(1) Modify <b>IntBufferDemo.java
</b>to use <b>doubles</b>. </span></p>

<p><span>Endians </span></p>

<p><span>Different machines may use
different byte-ordering approaches to store data. &quot;Big endian&quot; places
the most significant byte in the lowest memory address, and &quot;little
endian&quot; places the most significant byte in the highest memory address.
When storing a quantity that is greater than one <b>byte</b>, like <b>int</b>, <b>float</b>,
etc., you may need to consider the byte ordering. A <b>ByteBuffer </b>stores
data in big endian form, and data sent over a network always uses big endian
order. You can change the endian-ness of a <b>ByteBuffer </b>using <b>order( ) </b>with
an argument of <b>ByteOrder.BIG_ENDIAN </b>or <b>ByteOrder.LITTLE_ENDIAN</b>. </span></p>

<p><span>Consider a <b>ByteBuffer </b>containing
the following two bytes: </span></p>

<p><span>If you read the data as a <b>short
</b>(<b>ByteBuffer.asShortBuffer( )</b>), you will get the number 97 (00000000
01100001), but if you change to little endian, you will get the number 24832
(01100001 00000000). </span></p>

<p><span>Here's an example that
shows how byte ordering is changed in characters depending on the endian
setting: </span></p>

<p><i><span>I/O
687 </span></i></p>

<p><span>//:
io/Endians.java </span></p>

<p><span>// Endian
differences and data storage. </span></p>

<p><span>import
java.nio.*; </span></p>

<p><span>import
java.util.*; </span></p>

<p><span>import static
net.mindview.util.Print.*; </span></p>

<p><span>public class
Endians { </span></p>

<p><span>public static
void main(String[] args) { </span></p>

<p><span>ByteBuffer bb =
ByteBuffer.wrap(new byte[12]); </span></p>

<p><span>bb.asCharBuffer().put(&quot;abcdef&quot;);
</span></p>

<p><span>print(Arrays.toString(bb.array()));
</span></p>

<p><span>bb.rewind(); </span></p>

<p><span>bb.order(ByteOrder.BIG_ENDIAN);
</span></p>

<p><span>bb.asCharBuffer().put(&quot;abcdef&quot;);
</span></p>

<p><span>print(Arrays.toString(bb.array()));
</span></p>

<p><span>bb.rewind(); </span></p>

<p><span>bb.order(ByteOrder.LITTLE_ENDIAN);
</span></p>

<p><span>bb.asCharBuffer().put(&quot;abcdef&quot;);
</span></p>

<p><span>print(Arrays.toString(bb.array()));
</span></p>

<p><span>} </span></p>

<p><span>} /* Output: </span></p>

<p><span>[0, 97, 0, 98,
0, 99, 0, 100, 0, 101, 0, 102] </span></p>

<p><span>[0, 97, 0, 98,
0, 99, 0, 100, 0, 101, 0, 102] </span></p>

<p><span>[97, 0, 98, 0,
99, 0, 100, 0, 101, 0, 102, 0] </span></p>

<p><span>*///:~ </span></p>

<p><span>The <b>ByteBuffer </b>is
given enough space to hold all the bytes in <b>charArray </b>as an external
buffer so that the <b>array( ) </b>method can be called to display the
underlying bytes. The <b>array( ) </b>method is &quot;optional,&quot; and you
can only call it on a buffer that is backed by an array; otherwise, you'll get
an <b>UnsupportedOperationException</b>. </span></p>

<p><b><span>charArray </span></b><span>is inserted into the <b>ByteBuffer
</b>via a <b>CharBuffer </b>view. When the underlying bytes are displayed, you
can see that the default ordering is the same as the subsequent big endian
order, whereas the little endian order swaps the bytes. </span></p>

<p><span>Data manipulation
with buffers </span></p>

<p><span>The following diagram
illustrates the relationships between the <b>nio </b>classes, so that you can
see how to move and convert data. For example, if you wish to write a <b>byte </b>array
to a file, then you wrap the <b>byte </b>array using the <b>ByteBuffer.wrap( ) </b>method,
open a channel on the <b>FileOutputStream </b>using the <b>getChannel( ) </b>method,
and then write data into <b>FileChannel </b>from this <b>ByteBuffer. </b></span></p>

<p><i><span>688
Thinking in Java Bruce Eckel </span></i></p>

<p><span>Note that <b>ByteBuffer
</b>is the only way to move data into and out of channels, and that you can
only create a standalone primitive-typed buffer, or get one from a <b>ByteBuffer
</b>using an &quot;as&quot; method. That is, you cannot convert a
primitive-typed buffer <i>to </i>a <b>ByteBuffer</b>. However, since you are
able to move primitive data into and out of a <b>ByteBuffer </b>via a view
buffer, this is not really a restriction. </span></p>

<p><span>Buffer details </span></p>

<p><i><span>I/O
689 </span></i></p>

<table >
 <tr >
  <td width=385 valign=top >
  <p><b><span>A
  Buffer </span></b><span>consists of data and four indexes to access and manipulate
  this data efficiently: <i>mark</i>, <i>position</i>, <i>limit </i>and <i>capacity</i>.
  There are methods to set and reset these indexes and to query their value. </span><b><span>capacity( ) </span></b></p>
  </td>
  <td width=233 valign=top >
  <p><span>Returns the buffer's <i>capacity.
  </i></span></p>
  </td>
 </tr>
 <tr >
  <td width=385 valign=top >
  <p><b><span>clear( ) </span></b></p>
  </td>
  <td width=233 valign=top >
  <p><span>Clears the buffer, sets
  the <i>position </i>to zero, and <i>limit </i>to <i>capacity. </i>You call
  this method to overwrite an existing buffer. </span></p>
  </td>
 </tr>
 <tr >
  <td width=385 valign=top >
  <p><b><span>flip( ) </span></b></p>
  </td>
  <td width=233 valign=top >
  <p><span>Sets <i>limit </i>to <i>position
  </i>and <i>position </i>to zero. This method is used to prepare the buffer
  for a read after data has been written into it. </span></p>
  </td>
 </tr>
 <tr >
  <td width=385 valign=top >
  <p><b><span>limit( ) </span></b></p>
  </td>
  <td width=233 valign=top >
  <p><span>Returns the value of <i>limit.
  </i></span></p>
  </td>
 </tr>
 <tr >
  <td width=385 valign=top >
  <p><b><span>limit(int lim) </span></b></p>
  </td>
  <td width=233 valign=top >
  <p><span>Sets the value of <i>limit.
  </i></span></p>
  </td>
 </tr>
 <tr >
  <td width=385 valign=top >
  <p><b><span>mark( ) </span></b></p>
  </td>
  <td width=233 valign=top >
  <p><span>Sets <i>mark at
  position. </i></span></p>
  </td>
 </tr>
 <tr >
  <td width=385 valign=top >
  <p><b><span>position( ) </span></b></p>
  </td>
  <td width=233 valign=top >
  <p><span>Returns the value of <i>position.
  </i></span></p>
  </td>
 </tr>
 <tr >
  <td width=385 valign=top >
  <p><b><span>position(int pos) </span></b></p>
  </td>
  <td width=233 valign=top >
  <p><span>Sets the value <i>of
  position. </i></span></p>
  </td>
 </tr>
 <tr >
  <td width=385 valign=top >
  <p><b><span>remaining( ) </span></b></p>
  </td>
  <td width=233 valign=top >
  <p><span>Returns <i>(limit -
  position). </i></span></p>
  </td>
 </tr>
 <tr >
  <td width=385 valign=top >
  <p><b><span>hasRemaining( ) </span></b></p>
  </td>
  <td width=233 valign=top >
  <p><span>Returns <b>true </b>if
  there are any elements between <i>position </i>and <i>limit. </i></span></p>
  </td>
 </tr>
</table>

<p><span>Methods that
insert and extract data from the buffer update these indexes to reflect the
changes. </span></p>

<p><span>This example
uses a very simple algorithm (swapping adjacent characters) to scramble and
unscramble characters in a <b>CharBuffer</b>: </span></p>

<p><span>//:
io/UsingBuffers.java </span></p>

<p><span>import
java.nio.*; </span></p>

<p><span>import
static net.mindview.util.Print.*; </span></p>

<p><span>public
class UsingBuffers { </span></p>

<p><span>private
static void symmetricScramble(CharBuffer buffer){ </span></p>

<p><span>while(buffer.hasRemaining())
{ </span></p>

<p><span>buffer.mark();
</span></p>

<p><span>char
c1 = buffer.get(); </span></p>

<p><span>char
c2 = buffer.get(); </span></p>

<p><span>buffer.reset();
</span></p>

<p><span>buffer.put(c2).put(c1);
</span></p>

<p><span>} </span></p>

<p><span>} </span></p>

<p><span>public
static void main(String[] args) { </span></p>

<p><span>char[]
data = &quot;UsingBuffers&quot;.toCharArray(); </span></p>

<p><span>ByteBuffer
bb = ByteBuffer.allocate(data.length * 2); </span></p>

<p><span>CharBuffer
cb = bb.asCharBuffer(); </span></p>

<p><span>cb.put(data);
</span></p>

<p><span>print(cb.rewind());
</span></p>

<p><span>symmetricScramble(cb);
</span></p>

<p><span>print(cb.rewind());
</span></p>

<p><span>symmetricScramble(cb);
</span></p>

<p><span>print(cb.rewind());
</span></p>

<p><span>} </span></p>

<p><span>} /*
Output: </span></p>

<p><span>UsingBuffers
</span></p>

<p><span>sUniBgfuefsr
</span></p>

<p><i><span>690
Thinking in Java Bruce Eckel </span></i></p>

<p><span>UsingBuffers
</span></p>

<p><span>*///:~ </span></p>

<p><span>Although you could produce
a <b>CharBuffer </b>directly by calling <b>wrap( ) </b>with a <b>char </b>array,
an underlying <b>ByteBuffer </b>is allocated instead, and a <b>CharBuffer </b>is
produced as a view on the <b>ByteBuffer</b>. This emphasizes that the goal is
always to manipulate a <b>ByteBuffer</b>, since that is what interacts with a
channel. </span></p>

<p><span>Here's what the buffer
looks like at the entrance of the <b>symmetricScramble( ) </b>method: </span></p>

<p><span>The <i>position </i>points
to the first element in the buffer, and the <i>capacity </i>and <i>limit </i>point
to the last element. </span></p>

<p><span>In <b>symmetricScramble( )</b>,
the <b>while </b>loop iterates until <i>position </i>is equivalent to <i>limit</i>.
The <i>position </i>of the buffer changes when a relative <b>get( ) </b>or <b>put(
) </b>function is called on it. You can also call absolute <b>get( ) </b>and <b>put(
) </b>methods that include an index argument, which is the location where the <b>get(
) </b>or <b>put( ) </b>takes place. These methods do not modify the value of
the buffer's <i>position</i>. </span></p>

<p><span>When the control enters
the <b>while </b>loop, the value of <i>mark </i>is set using a <b>mark( ) </b>call.
The state of the buffer is then: </span></p>

<p><span>The two relative <b>get( )
</b>calls save the value of the first two characters in variables <b>c1 </b>and
<b>c2</b>. After these two calls, the buffer looks like this: </span></p>

<p><span>To perform the swap, we
need to write <b>c2 </b>at <i>position </i>= 0 and <b>c1 </b>at <i>position = </i>1.
We can either use the absolute put method to achieve this, or set the value of <i>position
</i>to <i>mark</i>, which is what <b>reset( ) </b>does: </span></p>

<p><i><span>I/O
691 </span></i></p>

<p><span>The two <b>put(
) </b>methods write <b>c2 </b>and then <b>c1: </b></span></p>

<p><span>During the next iteration
of the loop, <i>mark </i>is set to the current value of <i>position: </i></span></p>

<p><span>The process continues
until the entire buffer is traversed. At the end of the <b>while </b>loop, <i>position
</i>is at the end of the buffer. If you print the buffer, only the characters
between the <i>position </i>and <i>limit </i>are printed. Thus, if you want to
show the entire contents of the buffer, you must set <i>position </i>to the
start of the buffer using <b>rewind( )</b>. Here is the state of buffer after
the <b>rewind( ) </b>call (the value of <i>mark </i>becomes undefined): </span></p>

<p><span>When the function <b>symmetricScramble(
) </b>is called again, the <b>CharBuffer </b>undergoes the same process and is
restored to its original state. </span></p>

<p><span>Memory-mapped files </span></p>

<p><span>Memory-mapped files allow
you to create and modify files that are too big to bring into memory. With a
memory-mapped file, you can pretend that the entire file is in memory and that
you can access it by simply treating it as a very large array. This approach
greatly simplifies the code you write in order to modify the file. Here's a
small example: </span></p>

<p><span>//:
io/LargeMappedFiles.java </span></p>

<p><span>// Creating a
very large file using mapping. </span></p>

<p><span>// {RunByHand} </span></p>

<p><span>import
java.nio.*; </span></p>

<p><span>import
java.nio.channels.*; </span></p>

<p><i><span>692
Thinking in Java Bruce Eckel </span></i></p>

<p><span>import
java.io.*; </span></p>

<p><span>import static
net.mindview.util.Print.*; </span></p>

<p><span>public class
LargeMappedFiles { </span></p>

<p><span>static int
length = 0x8FFFFFF; // 128 MB </span></p>

<p><span>public static
void main(String[] args) throws Exception { </span></p>

<p><span>MappedByteBuffer
out = </span></p>

<p><span>new
RandomAccessFile(&quot;test.dat&quot;, &quot;rw&quot;).getChannel() </span></p>

<p><span>.map(FileChannel.MapMode.READ_WRITE,
0, length); </span></p>

<p><span>for(int i = 0; i
&lt; length; i++) </span></p>

<p><span>out.put((byte)</span><span>'</span><span>x</span><span>'</span><span>); </span></p>

<p><span>print(&quot;Finished
writing&quot;); </span></p>

<p><span>for(int i =
length/2; i &lt; length/2 + 6; i++) </span></p>

<p><span>printnb((char)out.get(i));
</span></p>

<p><span>} </span></p>

<p><span>} ///:~ </span></p>

<p><span>To do both writing and
reading, we start with a <b>RandomAccessFile</b>, get a channel for that file,
and then call <b>map( ) </b>to produce a <b>MappedByteBuffer</b>, which is a
particular kind of direct buffer. Note that you must specify the starting point
and the length of the region that you want to map in the file; this means that
you have the option to map smaller regions of a large file. </span></p>

<p><b><span>MappedByteBuffer </span></b><span>is inherited from <b>ByteBuffer</b>,
so it has all of <b>ByteBuffer</b>'s methods. Only the very simple uses of <b>put(
) </b>and <b>get( ) </b>are shown here, but you can also use methods like <b>asCharBuffer(
)</b>, etc. </span></p>

<p><span>The file created with the
preceding program is 128 MB long, which is probably larger than your OS will
allow in memory at one time. The file appears to be accessible all at once
because only portions of it are brought into memory, and other parts are
swapped out. This way a very large file (up to 2 GB) can easily be modified.
Note that the file-mapping facilities of the underlying operating system are
used to maximize performance. </span></p>

<p><span>Performance </span></p>

<p><span>Although the performance
of &quot;old&quot; stream I/O has been improved by implementing it with <b>nio</b>,
mapped file access tends to be dramatically faster. This program does a simple
performance comparison: </span></p>

<p><span>//:
io/MappedIO.java </span></p>

<p><span>import java.nio.*;
</span></p>

<p><span>import
java.nio.channels.*; </span></p>

<p><span>import
java.io.*; </span></p>

<p><span>public class
MappedIO { </span></p>

<p><span>private static
int numOfInts = 4000000; </span></p>

<p><span>private static
int numOfUbuffInts = 200000; </span></p>

<p><span>private abstract
static class Tester { </span></p>

<p><span>private String
name; </span></p>

<p><span>public
Tester(String name) { this.name = name; } </span></p>

<p><span>public void
runTest() { </span></p>

<p><span>System.out.print(name
+ &quot;: &quot;); </span></p>

<p><span>try { </span></p>

<p><span>long start =
System.nanoTime(); </span></p>

<p><span>test(); </span></p>

<p><span>double duration
= System.nanoTime() - start; </span></p>

<p><span>System.out.format(&quot;%.2f\n&quot;,
duration/1.0e9); </span></p>

<p><span>}
catch(IOException e) { </span></p>

<p><span>throw new
RuntimeException(e); </span></p>

<p><span>} </span></p>

<p><i><span>I/O
693 </span></i></p>

<p><span>}
</span></p>

<p><span>public abstract
void test() throws IOException; </span></p>

<p><span>} </span></p>

<p><span>private static
Tester[] tests = { </span></p>

<p><span>new
Tester(&quot;Stream Write&quot;) { </span></p>

<p><span>public void
test() throws IOException { </span></p>

<p><span>DataOutputStream
dos = new DataOutputStream( </span></p>

<p><span>new BufferedOutputStream(
</span></p>

<p><span>new
FileOutputStream(new File(&quot;temp.tmp&quot;)))); </span></p>

<p><span>for(int i = 0; i
&lt; numOfInts; i++) </span></p>

<p><span>dos.writeInt(i);
</span></p>

<p><span>dos.close(); </span></p>

<p><span>} </span></p>

<p><span>}, </span></p>

<p><span>new
Tester(&quot;Mapped Write&quot;) { </span></p>

<p><span>public void
test() throws IOException { </span></p>

<p><span>FileChannel fc =
</span></p>

<p><span>new
RandomAccessFile(&quot;temp.tmp&quot;, &quot;rw&quot;) </span></p>

<p><span>.getChannel(); </span></p>

<p><span>IntBuffer ib =
fc.map( </span></p>

<p><span>FileChannel.MapMode.READ_WRITE,
0, fc.size()) </span></p>

<p><span>.asIntBuffer(); </span></p>

<p><span>for(int i = 0; i
&lt; numOfInts; i++) </span></p>

<p><span>ib.put(i); </span></p>

<p><span>fc.close(); </span></p>

<p><span>} </span></p>

<p><span>}, </span></p>

<p><span>new
Tester(&quot;Stream Read&quot;) { </span></p>

<p><span>public void
test() throws IOException { </span></p>

<p><span>DataInputStream
dis = new DataInputStream( </span></p>

<p><span>new
BufferedInputStream( </span></p>

<p><span>new
FileInputStream(&quot;temp.tmp&quot;))); </span></p>

<p><span>for(int i = 0; i
&lt; numOfInts; i++) </span></p>

<p><span>dis.readInt(); </span></p>

<p><span>dis.close(); </span></p>

<p><span>} </span></p>

<p><span>}, </span></p>

<p><span>new
Tester(&quot;Mapped Read&quot;) { </span></p>

<p><span>public void
test() throws IOException { </span></p>

<p><span>FileChannel fc =
new FileInputStream( </span></p>

<p><span>new
File(&quot;temp.tmp&quot;)).getChannel(); </span></p>

<p><span>IntBuffer ib =
fc.map( </span></p>

<p><span>FileChannel.MapMode.READ_ONLY,
0, fc.size()) </span></p>

<p><span>.asIntBuffer(); </span></p>

<p><span>while(ib.hasRemaining())
</span></p>

<p><span>ib.get(); </span></p>

<p><span>fc.close(); </span></p>

<p><span>} </span></p>

<p><span>}, </span></p>

<p><span>new
Tester(&quot;Stream Read/Write&quot;) { </span></p>

<p><span>public void
test() throws IOException { </span></p>

<p><span>RandomAccessFile
raf = new RandomAccessFile( </span></p>

<p><span>new
File(&quot;temp.tmp&quot;), &quot;rw&quot;); </span></p>

<p><span>raf.writeInt(1);
</span></p>

<p><span>for(int i = 0; i
&lt; numOfUbuffInts; i++) { </span></p>

<p><span>raf.seek(raf.length()
- 4); </span></p>

<p><span>raf.writeInt(raf.readInt());
</span></p>

<p><span>} </span></p>

<p><span>raf.close(); </span></p>

<p><span>} </span></p>

<p><span>}, </span></p>

<p><span>new Tester(&quot;Mapped
Read/Write&quot;) { </span></p>

<p><span>public void
test() throws IOException { </span></p>

<p><i><span>694
Thinking in Java Bruce Eckel </span></i></p>

<p><span>FileChannel
fc = new RandomAccessFile( </span></p>

<p><span>new
File(&quot;temp.tmp&quot;), &quot;rw&quot;).getChannel(); </span></p>

<p><span>IntBuffer ib =
fc.map( </span></p>

<p><span>FileChannel.MapMode.READ_WRITE,
0, fc.size()) </span></p>

<p><span>.asIntBuffer(); </span></p>

<p><span>ib.put(0); </span></p>

<p><span>for(int i = 1; i
&lt; numOfUbuffInts; i++) </span></p>

<p><span>ib.put(ib.get(i
- 1)); </span></p>

<p><span>fc.close(); </span></p>

<p><span>} </span></p>

<p><span>} </span></p>

<p><span>}; </span></p>

<p><span>public static
void main(String[] args) { </span></p>

<p><span>for(Tester test
: tests) </span></p>

<p><span>test.runTest(); </span></p>

<p><span>} </span></p>

<p><span>} /* Output:
(90% match) </span></p>

<p><span>Stream Write:
0.56 </span></p>

<p><span>Mapped Write:
0.12 </span></p>

<p><span>Stream Read:
0.80 </span></p>

<p><span>Mapped Read:
0.07 </span></p>

<p><span>Stream
Read/Write: 5.32 </span></p>

<p><span>Mapped
Read/Write: 0.02 </span></p>

<p><span>*///:~ </span></p>

<p><span>As seen in earlier
examples in this book, <b>runTest( ) </b>is used by the <i>Template Method </i>to
create a testing framework for various implementations of <b>test( ) </b>defined
in anonymous inner subclasses. Each of these subclasses performs one kind of
test, so the <b>test( ) </b>methods also give you a prototype for performing
the various I/O activities. </span></p>

<p><span>Although a mapped write
would seem to use a <b>FileOutputStream</b>, all output in file mapping must
use a <b>RandomAccessFile</b>, just as read/write does in the preceding code. </span></p>

<p><span>Note that the <b>test( ) </b>methods
include the time for initialization of the various I/O objects, so even though
the setup for mapped files can be expensive, the overall gain compared to
stream I/O is significant. </span></p>

<p><b><span>Exercise 25: </span></b><span>(6) Experiment with
changing the <b>ByteBuffer.allocate( ) </b>statements in the examples in this
chapter to <b>ByteBuffer.allocateDirect( )</b>. Demonstrate performance
differences, but also notice whether the startup time of the programs
noticeably changes. </span></p>

<p><b><span>Exercise 26: </span></b><span>(3) Modify <b>strings/JGrep.java
</b>to use Java <b>nio </b>memorymapped files.</span></p>

<p><span>File
locking </span></p>

<p><span>File locking
allows you to synchronize access to a file as a shared resource. However, two
threads that contend for the same file may be in different JVMs, or one may be
a Java thread and the other some native thread in the operating system. The
file locks are visible to other operating system processes because Java file
locking maps directly to the native operating system locking facility. </span></p>

<p><span>Here is a
simple example of file locking. </span></p>

<p><span>//:
io/FileLocking.java </span></p>

<p><span>import
java.nio.channels.*; </span></p>

<p><span>import
java.util.concurrent.*; </span></p>

<p><span>import
java.io.*; </span></p>

<p><span>public
class FileLocking { </span></p>

<p><i><span>I/O
695 </span></i></p>

<p><span>public
static void main(String[] args) throws Exception { </span></p>

<p><span>FileOutputStream
fos= new FileOutputStream(&quot;file.txt&quot;); </span></p>

<p><span>FileLock fl =
fos.getChannel().tryLock(); </span></p>

<p><span>if(fl != null) {
</span></p>

<p><span>System.out.println(&quot;Locked
File&quot;); </span></p>

<p><span>TimeUnit.MILLISECONDS.sleep(100);
</span></p>

<p><span>fl.release(); </span></p>

<p><span>System.out.println(&quot;Released
Lock&quot;); </span></p>

<p><span>} </span></p>

<p><span>fos.close(); </span></p>

<p><span>} </span></p>

<p><span>} /* Output: </span></p>

<p><span>Locked File </span></p>

<p><span>Released Lock </span></p>

<p><span>*///:~ </span></p>

<p><span>You get a <b>FileLock </b>on
the entire file by calling either <b>tryLock( ) </b>or <b>lock( ) </b>on a <b>FileChannel</b>.
(<b>SocketChannel</b>, <b>DatagramChannel</b>, and <b>ServerSocketChannel </b>do
not need locking since they are inherently singleprocess entities; you don't
generally share a network socket between two processes.) <b>tryLock( ) </b>is
non-blocking. It tries to grab the lock, but if it cannot (when some other
process already holds the same lock and it is not shared), it simply returns
from the method call. <b>lock( ) </b>blocks until the lock is acquired, or the
thread that invoked <b>lock( ) </b>is interrupted, or the channel on which the <b>lock(
) </b>method is called is closed. A lock is released using <b>FileLock.release(
)</b>. </span></p>

<p><span>It is also possible to
lock a part of the file by using </span></p>

<p><span>tryLock(long
position, long size, boolean shared) </span></p>

<p><span>or </span></p>

<p><span>lock(long
position, long size, boolean shared) </span></p>

<p><span>which locks the region <b>(size
</b>- <b>position)</b>. The third argument specifies whether this lock is
shared. </span></p>

<p><span>Although the zero-argument
locking methods adapt to changes in the size of a file, locks with a fixed size
do not change if the file size changes. If a lock is acquired for a region from
<b>position </b>to <b>position+size </b>and the file increases beyond <b>position+size</b>,
then the section beyond <b>position+size </b>is not locked. The zero-argument
locking methods lock the entire file, even if it grows. </span></p>

<p><span>Support for exclusive or
shared locks must be provided by the underlying operating system. If the
operating system does not support shared locks and a request is made for one,
an exclusive lock is used instead. The type of lock (shared or exclusive) can
be queried using <b>FileLock.isShared( )</b>. </span></p>

<p><span>Locking portions of a
mapped file </span></p>

<p><span>As mentioned earlier, file
mapping is typically used for very large files. You may need to lock portions
of such a large file so that other processes may modify unlocked parts of the
file. This is something that happens, for example, with a database, so that it
can be available to many users at once. </span></p>

<p><span>Here's an example that has
two threads, each of which locks a distinct portion of a file: </span></p>

<p><span>//:
io/LockingMappedFiles.java </span></p>

<p><span>// Locking
portions of a mapped file. </span></p>

<p><i><span>696
Thinking in Java Bruce Eckel I/O 697 </span></i></p>

<p><sup><span>5 </span></sup><span>More details
about threads will be found in the <i>Concurrency </i>chapter. </span></p>

<p><span>&nbsp;</span></p>

<p><span>// {RunByHand} </span></p>

<p><span>import
java.nio.*; </span></p>

<p><span>import
java.nio.channels.*; </span></p>

<p><span>import
java.io.*; </span></p>

<p><span>public class
LockingMappedFiles { </span></p>

<p><span>static final int
LENGTH = 0x8FFFFFF; // 128 MB </span></p>

<p><span>static
FileChannel fc; </span></p>

<p><span>public static
void main(String[] args) throws Exception { </span></p>

<p><span>fc = </span></p>

<p><span>new
RandomAccessFile(&quot;test.dat&quot;, &quot;rw&quot;).getChannel(); </span></p>

<p><span>MappedByteBuffer
out = </span></p>

<p><span>fc.map(FileChannel.MapMode.READ_WRITE,
0, LENGTH); </span></p>

<p><span>for(int i = 0; i
&lt; LENGTH; i++) </span></p>

<p><span>out.put((byte)</span><span>'</span><span>x</span><span>'</span><span>); </span></p>

<p><span>new LockAndModify(out,
0, 0 + LENGTH/3); </span></p>

<p><span>new
LockAndModify(out, LENGTH/2, LENGTH/2 + LENGTH/4); </span></p>

<p><span>} </span></p>

<p><span>private static
class LockAndModify extends Thread { </span></p>

<p><span>private
ByteBuffer buff; </span></p>

<p><span>private int
start, end; </span></p>

<p><span>LockAndModify(ByteBuffer
mbb, int start, int end) { </span></p>

<p><span>this.start =
start; </span></p>

<p><span>this.end = end; </span></p>

<p><span>mbb.limit(end); </span></p>

<p><span>mbb.position(start);
</span></p>

<p><span>buff =
mbb.slice(); </span></p>

<p><span>start(); </span></p>

<p><span>} </span></p>

<p><span>public void
run() { </span></p>

<p><span>try { </span></p>

<p><span>// Exclusive
lock with no overlap: </span></p>

<p><span>FileLock fl =
fc.lock(start, end, false); </span></p>

<p><span>System.out.println(&quot;Locked:
&quot;+ start +&quot; to &quot;+ end); </span></p>

<p><span>// Perform
modification: </span></p>

<p><span>while(buff.position()
&lt; buff.limit() - 1) </span></p>

<p><span>buff.put((byte)(buff.get()
+ 1)); </span></p>

<p><span>fl.release(); </span></p>

<p><span>System.out.println(&quot;Released:
&quot;+start+&quot; to &quot;+ end); </span></p>

<p><span>}
catch(IOException e) { </span></p>

<p><span>throw new
RuntimeException(e); </span></p>

<p><span>} </span></p>

<p><span>} </span></p>

<p><span>} </span></p>

<p><span>} ///:~ </span></p>

<p><span>The <b>LockAndModify </b>thread
class sets up the buffer region and creates a <b>slice( ) </b>to be modified,
and in <b>run( )</b>, the lock is acquired on the file channel (you can't
acquire a lock on the bufferonly the channel). The call to <b>lock( ) </b>is
very similar to acquiring a threading lock on an objectyou now have a
&quot;critical section&quot; with exclusive access to that portion of the file.</span><span>5 </span></p>

<p><span>The locks are
automatically released when the JVM exits, or the channel on which it was
acquired is closed, but you can also explicitly call <b>release( ) </b>on the <b>FileLock
</b>object, as shown here. </span></p>

<p><span>Compression </span></p>

<p><span>The Java I/O library
contains classes to support reading and writing streams in a compressed format.
You wrap these around other I/O classes to provide compression functionality. </span></p>

<table >
 <tr >
  <td width=386 valign=top >
  <p><span>These
  classes are not derived from the <b>Reader </b>and <b>Writer </b>classes, but
  instead are part of the <b>InputStream </b>and <b>OutputStream </b>hierarchies.
  This is because the compression library works with bytes, not characters.
  However, you might sometimes be forced to mix the two types of streams.
  (Remember that you can use <b>InputStreamReader </b>and <b>OutputStream
  Writer </b>to provide easy conversion between one type and another.) </span><b><span>Compression class </span></b></p>
  </td>
  <td width=229 valign=top >
  <p><b><span>Function </span></b></p>
  </td>
 </tr>
 <tr >
  <td width=386 valign=top >
  <p><b><span>CheckedInputStream </span></b></p>
  </td>
  <td width=229 valign=top >
  <p><b><span>GetCheckSum( ) </span></b><span>produces checksum for
  any <b>InputStream </b>(not just decompression). </span></p>
  </td>
 </tr>
 <tr >
  <td width=386 valign=top >
  <p><b><span>CheckedOutputStream </span></b></p>
  </td>
  <td width=229 valign=top >
  <p><b><span>GetCheckSum( ) </span></b><span>produces checksum </span></p>
  <p><span>for any <b>OutputStream </b>(not
  just </span></p>
  <p><span>compression). </span></p>
  </td>
 </tr>
 <tr >
  <td width=386 valign=top >
  <p><b><span>DeflaterOutputStream </span></b></p>
  </td>
  <td width=229 valign=top >
  <p><span>Base class for
  compression classes. </span></p>
  </td>
 </tr>
 <tr >
  <td width=386 valign=top >
  <p><b><span>ZipOutputStream </span></b></p>
  </td>
  <td width=229 valign=top >
  <p><span>A <b>DeflaterOutputStream
  </b>that compresses data into the Zip file format. </span></p>
  </td>
 </tr>
 <tr >
  <td width=386 valign=top >
  <p><b><span>GZIPOutputStream </span></b></p>
  </td>
  <td width=229 valign=top >
  <p><span>A <b>DeflaterOutputStream
  </b>that compresses data into the GZIP file format. </span></p>
  </td>
 </tr>
 <tr >
  <td width=386 valign=top >
  <p><b><span>InflaterInputStream </span></b></p>
  </td>
  <td width=229 valign=top >
  <p><span>Base class for
  decompression classes. </span></p>
  </td>
 </tr>
 <tr >
  <td width=386 valign=top >
  <p><b><span>ZipInputStream </span></b></p>
  </td>
  <td width=229 valign=top >
  <p><span>An <b>InflaterInputStream
  </b>that decompresses data that has been stored in the Zip file format. </span></p>
  </td>
 </tr>
 <tr >
  <td width=386 valign=top >
  <p><b><span>GZIPInputStream </span></b></p>
  </td>
  <td width=229 valign=top >
  <p><span>An <b>InflaterInputStream
  </b>that </span></p>
  <p><span>decompresses data that
  has been stored in </span></p>
  <p><span>the GZIP file format. </span></p>
  </td>
 </tr>
</table>

<p><span>Although there
are many compression algorithms, Zip and GZIP are possibly the most commonly
used. Thus you can easily manipulate your compressed data with the many tools
available for reading and writing these formats. </span></p>

<p><span>Simple
compression with GZIP </span></p>

<p><span>The GZIP
interface is simple and thus is probably more appropriate when you have a
single stream of data that you want to compress (rather than a container of
dissimilar pieces of data). Here's an example that compresses a single file: </span></p>

<p><span>//:
io/GZIPcompress.java </span></p>

<p><span>//
{Args: GZIPcompress.java} </span></p>

<p><span>import
java.util.zip.*; </span></p>

<p><span>import
java.io.*; </span></p>

<p><span>public
class GZIPcompress { </span></p>

<p><span>public
static void main(String[] args) </span></p>

<p><span>throws
IOException { </span></p>

<p><span>if(args.length
== 0) { </span></p>

<p><i><span>698
Thinking in Java Bruce Eckel </span></i></p>

<p><span>System.out.println(
</span></p>

<p><span>&quot;Usage:
\nGZIPcompress file\n&quot; + </span></p>

<p><span>&quot;\tUses
GZIP compression to compress &quot; + </span></p>

<p><span>&quot;the file
to test.gz&quot;); </span></p>

<p><span>System.exit(1); </span></p>

<p><span>} </span></p>

<p><span>BufferedReader
in = new BufferedReader( </span></p>

<p><span>new
FileReader(args[0])); </span></p>

<p><span>BufferedOutputStream
out = new BufferedOutputStream( </span></p>

<p><span>new
GZIPOutputStream( </span></p>

<p><span>new
FileOutputStream(&quot;test.gz&quot;))); </span></p>

<p><span>System.out.println(&quot;Writing
file&quot;); </span></p>

<p><span>int c; </span></p>

<p><span>while((c =
in.read()) != -1) </span></p>

<p><span>out.write(c); </span></p>

<p><span>in.close(); </span></p>

<p><span>out.close(); </span></p>

<p><span>System.out.println(&quot;Reading
file&quot;); </span></p>

<p><span>BufferedReader
in2 = new BufferedReader( </span></p>

<p><span>new
InputStreamReader(new GZIPInputStream( </span></p>

<p><span>new
FileInputStream(&quot;test.gz&quot;)))); </span></p>

<p><span>String s; </span></p>

<p><span>while((s =
in2.readLine()) != null) </span></p>

<p><span>System.out.println(s);
</span></p>

<p><span>} </span></p>

<p><span>} /* (Execute to
see output) *///:~ </span></p>

<p><span>The use of the compression
classes is straightforward; you simply wrap your output stream in a <b>GZIPOutputStream
</b>or <b>ZipOutputStream</b>, and your input stream in a <b>GZIPInputStream </b>or
<b>ZipInputStream</b>. All else is ordinary I/O reading and writing. This is an
example of mixing the <b>char</b>-oriented streams with the byte-oriented
streams; <b>in </b>uses the <b>Reader </b>classes, whereas <b>GZIPOutputStream</b>'s
constructor can accept only an <b>OutputStream </b>object, not a <b>Writer </b>object.
When the file is opened, the <b>GZIPInputStream </b>is converted to a <b>Reader</b>.
</span></p>

<p><span>Multifile storage
with Zip </span></p>

<p><span>The library that supports
the Zip format is more extensive. With it you can easily store multiple files,
and there's even a separate class to make the process of reading a Zip file
easy. The library uses the standard Zip format so that it works seamlessly with
all the Zip tools currently downloadable on the Internet. The following example
has the same form as the previous example, but it handles as many command-line
arguments as you want. In addition, it shows the use of the <b>Checksum </b>classes
to calculate and verify the checksum for the file. There are two <b>Checksum </b>types:
<b>Adler32 </b>(which is faster) and <b>CRC32 </b>(which is slower but slightly
more accurate). </span></p>

<p><span>//:
io/ZipCompress.java </span></p>

<p><span>// Uses Zip
compression to compress any </span></p>

<p><span>// number of
files given on the command line. </span></p>

<p><span>// {Args:
ZipCompress.java} </span></p>

<p><span>import
java.util.zip.*; </span></p>

<p><span>import
java.io.*; </span></p>

<p><span>import
java.util.*; </span></p>

<p><span>import static
net.mindview.util.Print.*; </span></p>

<p><span>public class
ZipCompress { </span></p>

<p><span>public static
void main(String[] args) </span></p>

<p><span>throws
IOException { </span></p>

<p><span>FileOutputStream
f = new FileOutputStream(&quot;test.zip&quot;); </span></p>

<p><span>CheckedOutputStream
csum = </span></p>

<p><i><span>I/O
699 </span></i></p>

<p><span>new
CheckedOutputStream(f, new Adler32()); </span></p>

<p><span>ZipOutputStream
zos = new ZipOutputStream(csum); </span></p>

<p><span>BufferedOutputStream
out = </span></p>

<p><span>new
BufferedOutputStream(zos); </span></p>

<p><span>zos.setComment(&quot;A
test of Java Zipping&quot;); </span></p>

<p><span>// No
corresponding getComment(), though. </span></p>

<p><span>for(String arg :
args) { </span></p>

<p><span>print(&quot;Writing
file &quot; + arg); </span></p>

<p><span>BufferedReader
in = </span></p>

<p><span>new
BufferedReader(new FileReader(arg)); </span></p>

<p><span>zos.putNextEntry(new
ZipEntry(arg)); </span></p>

<p><span>int c; </span></p>

<p><span>while((c =
in.read()) != -1) </span></p>

<p><span>out.write(c); </span></p>

<p><span>in.close(); </span></p>

<p><span>out.flush(); </span></p>

<p><span>} </span></p>

<p><span>out.close(); </span></p>

<p><span>// Checksum
valid only after the file has been closed! </span></p>

<p><span>print(&quot;Checksum:
&quot; + csum.getChecksum().getValue()); </span></p>

<p><span>// Now extract
the files: </span></p>

<p><span>print(&quot;Reading
file&quot;); </span></p>

<p><span>FileInputStream
fi = new FileInputStream(&quot;test.zip&quot;); </span></p>

<p><span>CheckedInputStream
csumi = </span></p>

<p><span>new
CheckedInputStream(fi, new Adler32()); </span></p>

<p><span>ZipInputStream
in2 = new ZipInputStream(csumi); </span></p>

<p><span>BufferedInputStream
bis = new BufferedInputStream(in2); </span></p>

<p><span>ZipEntry ze; </span></p>

<p><span>while((ze =
in2.getNextEntry()) != null) { </span></p>

<p><span>print(&quot;Reading
file &quot; + ze); </span></p>

<p><span>int x; </span></p>

<p><span>while((x =
bis.read()) != -1) </span></p>

<p><span>System.out.write(x);
</span></p>

<p><span>} </span></p>

<p><span>if(args.length
== 1) </span></p>

<p><span>print(&quot;Checksum:
&quot; + csumi.getChecksum().getValue()); </span></p>

<p><span>bis.close(); </span></p>

<p><span>// Alternative
way to open and read Zip files: </span></p>

<p><span>ZipFile zf = new
ZipFile(&quot;test.zip&quot;); </span></p>

<p><span>Enumeration e =
zf.entries(); </span></p>

<p><span>while(e.hasMoreElements())
{ </span></p>

<p><span>ZipEntry ze2 =
(ZipEntry)e.nextElement(); </span></p>

<p><span>print(&quot;File:
&quot; + ze2); </span></p>

<p><span>// ... and
extract the data as before </span></p>

<p><span>} </span></p>

<p><span>/*
if(args.length == 1) */ </span></p>

<p><span>} </span></p>

<p><span>} /* (Execute to
see output) *///:~ </span></p>

<p><span>For each file to add to
the archive, you must call <b>putNextEntry( ) </b>and pass it a <b>ZipEntry </b>object.
The <b>ZipEntry </b>object contains an extensive interface that allows you to
get and set all the data available on that particular entry in your Zip file:
name, compressed and uncompressed sizes, date, CRC checksum, extra field data,
comment, compression method, and whether it's a directory entry. However, even
though the Zip format has a way to set a password, this is not supported in
Java's Zip library. And although <b>CheckedInputStream </b>and <b>CheckedOutputStream
</b>support both <b>Adler32 </b>and <b>CRC32 </b>checksums, the <b>ZipEntry </b>class
supports only an interface for CRC. This is a restriction of the underlying Zip
format, but it might limit you from using the faster <b>Adler32</b>. </span></p>

<p><span>To extract files, <b>ZipInputStream
</b>has a <b>getNextEntry( ) </b>method that returns the next <b>ZipEntry </b>if
there is one. As a more succinct alternative, you can read the file using a </span></p>

<p><i><span>700
Thinking in Java Bruce Eckel </span></i></p>

<p><b><span>ZipFile </span></b><span>object, which has a method
<b>entries( ) </b>to return an <b>Enumeration </b>to the <b>ZipEntries</b>. </span></p>

<p><span>In order to read the
checksum, you must somehow have access to the associated <b>Checksum </b>object.
Here, a reference to the <b>CheckedOutputStream </b>and <b>CheckedInputStream </b>objects
is retained, but you could also just hold on to a reference to the <b>Checksum </b>object.
</span></p>

<p><span>A baffling method in Zip
streams is <b>setComment( )</b>. As shown in <b>ZipCompress.java</b>, you can set
a comment when you're writing a file, but there's no way to recover the comment
in the <b>ZipInputStream</b>. Comments appear to be supported fully on an
entry-by-entry basis only via <b>ZipEntry</b>. Of course, you are not limited
to files when using the <b>GZIP </b>or <b>Zip </b>libraries you can compress
anything, including data to be sent through a network connection. </span></p>

<p><span>Java ARchives (JARs) </span></p>

<p><span>The Zip format is also
used in the JAR (Java ARchive) file format, which is a way to collect a group
of files into a single compressed file, just like Zip. However, like everything
else in Java, JAR files are cross-platform, so you don't need to worry about
platform issues. You can also include audio and image files as well as class
files. </span></p>

<p><span>JAR files are particularly
helpful when you deal with the Internet. Before JAR files, your Web browser
would have to make repeated requests of a Web server in order to download all
the files that made up an applet. In addition, each of these files was
uncompressed. By combining all of the files for a particular applet into a
single JAR file, only one server request is necessary and the transfer is
faster because of compression. And each entry in a JAR file can be digitally
signed for security. </span></p>

<p><span>A JAR file consists of a
single file containing a collection of zipped files along with a
&quot;manifest&quot; that describes them. (You can create your own manifest
file; otherwise, the <b>jar </b>program will do it for you.) You can find out
more about JAR manifests in the JDK documentation. </span></p>

<p><span>The <b>jar </b>utility
that comes with Sun's JDK automatically compresses the files of your choice.
You invoke it on the command line: </span></p>

<p><span>jar [options]
destination [manifest] inputfile(s) </span></p>

<table >
 <tr >
  <td width=384 valign=top >
  <p><span>The
  options are simply a collection of letters (no hyphen or any other indicator
  is necessary). Unix/Linux users will note the similarity to the <b>tar </b>options.
  These are: </span><b><span>c
  </span></b></p>
  </td>
  <td width=221 valign=top >
  <p><span>Creates a new or empty
  archive. </span></p>
  </td>
 </tr>
 <tr >
  <td width=384 valign=top >
  <p><b><span>t </span></b></p>
  </td>
  <td width=221 valign=top >
  <p><span>Lists the table of
  contents. </span></p>
  </td>
 </tr>
 <tr >
  <td width=384 valign=top >
  <p><b><span>x </span></b></p>
  </td>
  <td width=221 valign=top >
  <p><span>Extracts all files. </span></p>
  </td>
 </tr>
 <tr >
  <td width=384 valign=top >
  <p><b><span>x file </span></b></p>
  </td>
  <td width=221 valign=top >
  <p><span>Extracts the named file.
  </span></p>
  </td>
 </tr>
 <tr >
  <td width=384 valign=top >
  <p><b><span>f </span></b></p>
  </td>
  <td width=221 valign=top >
  <p><span>Says, &quot;I'm going to
  give you the name of the file.&quot; If you don't use this, <b>jar </b>assumes
  that its input will come from standard input, or, if it is creating a file,
  its output will go to standard output. </span></p>
  </td>
 </tr>
 <tr >
  <td width=384 valign=top >
  <p><b><span>m </span></b></p>
  </td>
  <td width=221 valign=top >
  <p><span>Says that the first
  argument will be the name of the user-created manifest file. </span></p>
  </td>
 </tr>
 <tr >
  <td width=384 valign=top >
  <p><b><span>v </span></b></p>
  </td>
  <td width=221 valign=top >
  <p><span>Generates verbose output
  describing what <b>jar </b>is doing. </span></p>
  </td>
 </tr>
</table>

<p>&nbsp;</p>

<p><span>If a
subdirectory is included in the files to be put into the JAR file, that
subdirectory is automatically added, including all of its subdirectories, etc.
Path information is also preserved. </span></p>

<p><span>Here are some
typical ways to invoke <b>jar</b>. The following command creates a JAR file
called <b>myJarFile.jar </b>that contains all of the class files in the current
directory, along with an automatically generated manifest file: </span></p>

<p><span>jar
cf myJarFile.jar *.class </span></p>

<p><span>The next
command is like the previous example, but it adds a user-created manifest file
called <b>myManifestFile.mf</b>: </span></p>

<p><span>jar
cmf myJarFile.jar myManifestFile.mf *.class </span></p>

<p><span>This produces
a table of contents of the files in <b>myJarFile.jar: </b></span></p>

<p><span>jar
tf myJarFile.jar </span></p>

<p><span>This adds the
&quot;verbose&quot; flag to give more detailed information about the files in <b>myJarFile.jar:
</b></span></p>

<p><span>jar
tvf myJarFile.jar </span></p>

<p><span>Assuming <b>audio</b>,
<b>classes</b>, and <b>image </b>are subdirectories, this combines all of the
subdirectories into the file <b>myApp.jar</b>. The &quot;verbose&quot; flag is
also included to give extra feedback while the <b>jar </b>program is working: </span></p>

<p><span>jar
cvf myApp.jar audio classes image </span></p>

<p><span>If you create
a JAR file using the <b>o </b>(zero) option, that file can be placed in your
CLASSPATH: </span></p>

<p><span>CLASSPATH=&quot;libl.jar;lib2.jar;&quot;
</span></p>

<p><span>Then Java can search
<b>lib1.jar </b>and <b>lib2.jar </b>for class files. </span></p>

<p><span>The <b>jar </b>tool
isn't as general-purpose as a <b>Zip </b>utility. For example, you can't add or
update files to an existing JAR file; you can create JAR files only from
scratch. Also, you can't move files into a JAR file, erasing them as they are
moved. However, a JAR file created on one platform will be transparently
readable by the <b>jar </b>tool on any other platform (a problem that sometimes
plagues <b>Zip </b>utilities). </span></p>

<p><span>As you will
see in the <i>Graphical User Interfaces </i>chapter, JAR files are also used to
package JavaBeans. </span></p>

<p><i><span>702
Thinking in Java Bruce Eckel </span></i></p>

<p><span>Object
serialization </span></p>

<p><span>When you create an object,
it exists for as long as you need it, but under no circumstances does it exist
when the program terminates. While this makes sense at first, there are
situations in which it would be incredibly useful if an object could exist and
hold its information even while the program wasn't running. Then, the next time
you started the program, the object would be there and it would have the same
information it had the previous time the program was running. Of course, you
can get a similar effect by writing the information to a file or to a database,
but in the spirit of making everything an object, it would be quite convenient
to declare an object to be &quot;persistent,&quot; and have all the details
taken care of for you. </span></p>

<p><span>Java's <i>object
serialization </i>allows you to take any object that implements the <b>Serializable
</b>interface and turn it into a sequence of bytes that can later be fully
restored to regenerate the original object. This is even true across a network,
which means that the serialization mechanism automatically compensates for
differences in operating systems. That is, you can create an object on a
Windows machine, serialize it, and send it across the network to a Unix
machine, where it will be correctly reconstructed. You don't have to worry
about the data representations on the different machines, the byte ordering, or
any other details. </span></p>

<p><span>By itself, object
serialization is interesting because it allows you to implement <i>lightweight
persistence</i>. Persistence means that an object's lifetime is not determined
by whether a program is executing; the object lives <i>in between </i>invocations
of the program. By taking a serializable object and writing it to disk, then
restoring that object when the program is reinvoked, you're able to produce the
effect of persistence. The reason it's called &quot;lightweight&quot; is that
you can't simply define an object using some kind of &quot;persistent&quot;
keyword and let the system take care of the details (perhaps this will happen
in the future). Instead, you must explicitly serialize and deserialize the
objects in your program. If you need a more serious persistence mechanism,
consider a tool like Hibernate <i>(http://hibernate.sourceforge.net)</i>. For
details, see <i>Thinking in Enterprise Java</i>, downloadable from <i>www.MindView.net</i>.
</span></p>

<p><span>Object serialization was
added to the language to support two major features. Java's <i>Remote Method
Invocation </i>(RMI) allows objects that live on other machines to behave as if
they live on your machine. When messages are sent to remote objects, object
serialization is necessary to transport the arguments and return values. RMI is
discussed in <i>Thinking in Enterprise Java</i>. Object serialization is also
necessary for JavaBeans, described in the <i>Graphical User Interfaces </i>chapter.
When a Bean is used, its state information is generally configured at design
time. This state information must be stored and later recovered when the
program is started; object serialization performs this task. </span></p>

<p><span>Serializing an object is
quite simple as long as the object implements the <b>Serializable </b>interface
(this is a tagging interface and has no methods). When serialization was added
to the language, many standard library classes were changed to make them
serializable, including all of the wrappers for the primitive types, all of the
container classes, and many others. Even <b>Class </b>objects can be
serialized. </span></p>

<p><span>To serialize an object,
you create some sort of <b>OutputStream </b>object and then wrap it inside an <b>ObjectOutputStream
</b>object. At this point you need only call <b>writeObject( )</b>, and your
object is serialized and sent to the <b>OutputStream </b>(object serialization
is byte-oriented, and thus uses the <b>InputStream </b>and <b>OutputStream </b>hierarchies).
To reverse the process, you wrap an <b>InputStream </b>inside an <b>ObjectlnputStream
</b>and call <b>readObject( )</b>. What comes back is, as usual, a reference to
an upcast <b>Object</b>, so you must downcast to set things straight. </span></p>

<p><span>A particularly clever
aspect of object serialization is that it not only saves an image of your
object, but it also follows all the references contained in your object and
saves <i>those </i>objects, and follows all the references in each of those
objects, etc. This is sometimes referred to as </span></p>

<p><i><span>I/O
703 </span></i></p>

<p><span>the &quot;web
of objects&quot; that a single object can be connected to, and it includes
arrays of references to objects as well as member objects. If you had to
maintain your own object serialization scheme, maintaining the code to follow
all these links could be mindboggling. However, Java object serialization seems
to pull it off flawlessly, no </span><span>doubt using an optimized algorithm that traverses the web of
objects. The following example tests the serialization mechanism by making a
&quot;worm&quot; of linked objects, each of which has a link to the next
segment in the worm as well as an array of references to objects of a different
class, <b>Data</b>: </span></p>

<p><span>//: io/Worm.java
</span></p>

<p><span>// Demonstrates
object serialization. </span></p>

<p><span>import
java.io.*; </span></p>

<p><span>import
java.util.*; </span></p>

<p><span>import static
net.mindview.util.Print.*; </span></p>

<p><span>class Data implements
Serializable { </span></p>

<p><span>private int n; </span></p>

<p><span>public Data(int
n) { this.n = n; } </span></p>

<p><span>public String
toString() { return Integer.toString(n); } </span></p>

<p><span>} </span></p>

<p><span>public class
Worm implements Serializable { </span></p>

<p><span>private static
Random rand = new Random(47); </span></p>

<p><span>private Data[] d
= { </span></p>

<p><span>new Data(rand.nextInt(10)),
</span></p>

<p><span>new
Data(rand.nextInt(10)), </span></p>

<p><span>new
Data(rand.nextInt(10)) </span></p>

<p><span>}; </span></p>

<p><span>private Worm
next; </span></p>

<p><span>private char c; </span></p>

<p><span>// Value of i ==
number of segments </span></p>

<p><span>public Worm(int
i, char x) { </span></p>

<p><span>print(&quot;Worm
constructor: &quot; + i); </span></p>

<p><span>c = x; </span></p>

<p><span>if(--i &gt; 0) </span></p>

<p><span>next = new Worm(i,
(char)(x + 1)); </span></p>

<p><span>} </span></p>

<p><span>public Worm() { </span></p>

<p><span>print(&quot;Default
constructor&quot;); </span></p>

<p><span>} </span></p>

<p><span>public String
toString() { </span></p>

<p><span>StringBuilder
result = new StringBuilder(&quot;:&quot;); </span></p>

<p><span>result.append(c);
</span></p>

<p><span>result.append(&quot;(&quot;);
</span></p>

<p><span>for(Data dat :
d) </span></p>

<p><span>result.append(dat);
</span></p>

<p><span>result.append(&quot;)&quot;);
</span></p>

<p><span>if(next != null)
</span></p>

<p><span>result.append(next);
</span></p>

<p><span>return
result.toString(); </span></p>

<p><span>} </span></p>

<p><span>public static
void main(String[] args) </span></p>

<p><span>throws
ClassNotFoundException, IOException { </span></p>

<p><span>Worm w = new
Worm(6, </span><span></span><span>a</span><span>'</span><span>); </span></p>

<p><span>print(&quot;w =
&quot; + w); </span></p>

<p><span>ObjectOutputStream
out = new ObjectOutputStream( </span></p>

<p><span>new FileOutputStream(&quot;worm.out&quot;));
</span></p>

<p><span>out.writeObject(&quot;Worm
storage\n&quot;); </span></p>

<p><span>out.writeObject(w);
</span></p>

<p><span>out.close(); //
Also flushes output </span></p>

<p><span>ObjectInputStream
in = new ObjectInputStream( </span></p>

<p><span>new
FileInputStream(&quot;worm.out&quot;)); </span></p>

<p><span>String s =
(String)in.readObject(); </span></p>

<p><i><span>704
Thinking in Java Bruce Eckel </span></i></p>

<p><span>Worm
w2 = (Worm)in.readObject(); </span></p>

<p><span>print(s +
&quot;w2 = &quot; + w2); </span></p>

<p><span>ByteArrayOutputStream
bout = </span></p>

<p><span>new
ByteArrayOutputStream(); </span></p>

<p><span>ObjectOutputStream
out2 = new ObjectOutputStream(bout); </span></p>

<p><span>out2.writeObject(&quot;Worm
storage\n&quot;); </span></p>

<p><span>out2.writeObject(w);
</span></p>

<p><span>out2.flush(); </span></p>

<p><span>ObjectInputStream
in2 = new ObjectInputStream( </span></p>

<p><span>new
ByteArrayInputStream(bout.toByteArray())); </span></p>

<p><span>s =
(String)in2.readObject(); </span></p>

<p><span>Worm w3 =
(Worm)in2.readObject(); </span></p>

<p><span>print(s +
&quot;w3 = &quot; + w3); </span></p>

<p><span>} </span></p>

<p><span>} /* Output: </span></p>

<p><span>Worm
constructor: 6 </span></p>

<p><span>Worm constructor:
5 </span></p>

<p><span>Worm
constructor: 4 </span></p>

<p><span>Worm
constructor: 3 </span></p>

<p><span>Worm
constructor: 2 </span></p>

<p><span>Worm
constructor: 1 </span></p>

<p><span>w =
:a(853):b(119):c(802):d(788):e(199):f(881) </span></p>

<p><span>Worm storage </span></p>

<p><span>w2 =
:a(853):b(119):c(802):d(788):e(199):f(881) </span></p>

<p><span>Worm storage </span></p>

<p><span>w3 =
:a(853):b(119):c(802):d(788):e(199):f(881) </span></p>

<p><span>*///:~ </span></p>

<p><span>To make things
interesting, the array of <b>Data </b>objects inside <b>Worm </b>are
initialized with random numbers. (This way, you don't suspect the compiler of
keeping some kind of meta-information.) Each <b>Worm </b>segment is labeled
with a <b>char </b>that's automatically generated in the process of recursively
generating the linked list of <b>Worm</b>s. When you create a <b>Worm</b>, you
tell the constructor how long you want it to be. To make the <b>next </b>reference,
it calls the <b>Worm </b>constructor with a length of one less, etc. The final <b>next
</b>reference is left as <b>null</b>, indicating the end of the <b>Worm</b>. </span></p>

<p><span>The point of all this was
to make something reasonably complex that couldn't easily be serialized. The
act of serializing, however, is quite simple. Once the <b>ObjectOutputStream </b>is
created from some other stream, <b>writeObject( ) </b>serializes the object.
Notice the call to <b>writeObject( ) </b>for a <b>String</b>, as well. You can
also write all the primitive data types using the same methods as <b>DataOutputStream
</b>(they share the same interface). </span></p>

<p><span>There are two separate
code sections that look similar. The first writes and reads a file, and the
second, for variety, writes and reads a <b>ByteArray</b>. You can read and
write an object using serialization to any <b>DataInputStream </b>or <b>DataOutputStream</b>,
including, as you can see in <i>Thinking in Enterprise Java</i>, a network. </span></p>

<p><span>You can see from the
output that the deserialized object really does contain all of the links that
were in the original object. </span></p>

<p><span>Note that no constructor,
not even the default constructor, is called in the process of deserializing a <b>Serializable
</b>object. The entire object is restored by recovering data from the <b>InputStream</b>.
</span></p>

<p><b><span>Exercise 27: </span></b><span>(1) Create a <b>Serializable
</b>class containing a reference to an object of a second <b>Serializable </b>class.
Create an instance of your class, serialize it to disk, then restore it and
verify that the process worked correctly. </span></p>

<p><i><span>I/O
705 </span></i></p>

<p><span>Finding
the class </span></p>

<p><span>You might wonder what's
necessary for an object to be recovered from its serialized state. For example,
suppose you serialize an object and send it as a file or through a network to
another machine. Could a program on the other machine reconstruct the object
using only the contents of the file? </span></p>

<p><span>The best way to answer
this question is (as usual) by performing an experiment. The following file
goes in the subdirectory for this chapter: </span></p>

<p><span>//:
io/Alien.java </span></p>

<p><span>// A
serializable class. </span></p>

<p><span>import
java.io.*; </span></p>

<p><span>public class
Alien implements Serializable {} ///:~ </span></p>

<p><span>The file that creates and
serializes an <b>Alien </b>object goes in the same directory: </span></p>

<p><span>//:
io/FreezeAlien.java </span></p>

<p><span>// Create a
serialized output file. </span></p>

<p><span>import
java.io.*; </span></p>

<p><span>public class
FreezeAlien { </span></p>

<p><span>public static
void main(String[] args) throws Exception { </span></p>

<p><span>ObjectOutput out
= new ObjectOutputStream( </span></p>

<p><span>new
FileOutputStream(&quot;X.file&quot;)); </span></p>

<p><span>Alien quellek =
new Alien(); </span></p>

<p><span>out.writeObject(quellek);
</span></p>

<p><span>} </span></p>

<p><span>} ///:~ </span></p>

<p><span>Rather than catching and
handling exceptions, this program takes the quickand- dirty approach of passing
the exceptions out of <b>main( )</b>, so they'll be reported on the console. </span></p>

<p><span>Once the program is
compiled and run, it produces a file called <b>X.file </b>in the <b>io </b>directory.
The following code is in a subdirectory called <b>xfiles</b>: </span></p>

<p><span>//:
io/xfiles/ThawAlien.java </span></p>

<p><span>// Try to
recover a serialized file without the </span></p>

<p><span>// class of
object that</span><span>'</span><span>s stored in that file. </span></p>

<p><span>// {RunByHand} </span></p>

<p><span>import
java.io.*; </span></p>

<p><span>public class
ThawAlien { </span></p>

<p><span>public static
void main(String[] args) throws Exception { </span></p>

<p><span>ObjectInputStream
in = new ObjectInputStream( </span></p>

<p><span>new
FileInputStream(new File(&quot;..&quot;, &quot;X.file&quot;))); </span></p>

<p><span>Object mystery =
in.readObject(); </span></p>

<p><span>System.out.println(mystery.getClass());
</span></p>

<p><span>} </span></p>

<p><span>} /* Output: </span></p>

<p><span>class Alien </span></p>

<p><span>*///:~ </span></p>

<p><span>Even opening the file and
reading in the object <b>mystery </b>requires the <b>Class </b>object for <b>Alien</b>;
the JVM cannot find <b>Alien.class </b>(unless it happens to be in the
classpath, which it shouldn't be in this example). You'll get a <b>ClassNotFoundException</b>.
(Once again, all evidence of alien life vanishes before proof of its existence
can be verified!) The JVM must be able to find the associated <b>.class </b>file.
</span></p>

<p><i><span>706
Thinking in Java Bruce Eckel </span></i></p>

<p><span>Controlling
serialization </span></p>

<p><span>As you can see, the
default serialization mechanism is trivial to use. But what if you have special
needs? Perhaps you have special security issues and you don't want to serialize
portions of your object, or perhaps it just doesn't make sense for one
subobject to be serialized if that part needs to be created anew when the
object is recovered. </span></p>

<p><span>You can control the
process of serialization by implementing the <b>Externalizable </b>interface
instead of the <b>Serializable </b>interface. The <b>Externalizable </b>interface
extends the <b>Serializable </b>interface and adds two methods, <b>writeExternal(
) </b>and <b>readExternal( )</b>, that are automatically called for your object
during serialization and deserialization so that you can perform your special
operations. </span></p>

<p><span>The following example
shows simple implementations of the <b>Externalizable </b>interface methods.
Note that <b>Blip1 </b>and <b>Blip2 </b>are nearly identical except for a
subtle difference (see if you can discover it by looking at the code): </span></p>

<p><span>//:
io/Blips.java </span></p>

<p><span>// Simple use of
Externalizable &amp; a pitfall. </span></p>

<p><span>import
java.io.*; </span></p>

<p><span>import static
net.mindview.util.Print.*; </span></p>

<p><span>class Blip1
implements Externalizable { </span></p>

<p><span>public Blip1() {
</span></p>

<p><span>print(&quot;Blip1
Constructor&quot;); </span></p>

<p><span>} </span></p>

<p><span>public void
writeExternal(ObjectOutput out) </span></p>

<p><span>throws
IOException { </span></p>

<p><span>print(&quot;Blip1.writeExternal&quot;);
</span></p>

<p><span>} </span></p>

<p><span>public void
readExternal(ObjectInput in) </span></p>

<p><span>throws
IOException, ClassNotFoundException { </span></p>

<p><span>print(&quot;Blip1.readExternal&quot;);
</span></p>

<p><span>} </span></p>

<p><span>} </span></p>

<p><span>class Blip2
implements Externalizable { </span></p>

<p><span>Blip2() { </span></p>

<p><span>print(&quot;Blip2
Constructor&quot;); </span></p>

<p><span>} </span></p>

<p><span>public void
writeExternal(ObjectOutput out) </span></p>

<p><span>throws
IOException { </span></p>

<p><span>print(&quot;Blip2.writeExternal&quot;);
</span></p>

<p><span>} </span></p>

<p><span>public void
readExternal(ObjectInput in) </span></p>

<p><span>throws
IOException, ClassNotFoundException { </span></p>

<p><span>print(&quot;Blip2.readExternal&quot;);
</span></p>

<p><span>} </span></p>

<p><span>} </span></p>

<p><span>public class
Blips { </span></p>

<p><span>public static
void main(String[] args) </span></p>

<p><span>throws
IOException, ClassNotFoundException { </span></p>

<p><span>print(&quot;Constructing
objects:&quot;); </span></p>

<p><span>Blip1 b1 = new
Blip1(); </span></p>

<p><span>Blip2 b2 = new
Blip2(); </span></p>

<p><span>ObjectOutputStream
o = new ObjectOutputStream( </span></p>

<p><span>new
FileOutputStream(&quot;Blips.out&quot;)); </span></p>

<p><span>print(&quot;Saving
objects:&quot;); </span></p>

<p><span>o.writeObject(b1);
</span></p>

<p><i><span>I/O
707 </span></i></p>

<p><span>o.writeObject(b2);
</span></p>

<p><span>o.close(); </span></p>

<p><span>// Now get them
back: </span></p>

<p><span>ObjectInputStream
in = new ObjectInputStream( </span></p>

<p><span>new
FileInputStream(&quot;Blips.out&quot;)); </span></p>

<p><span>print(&quot;Recovering
b1:&quot;); </span></p>

<p><span>b1 =
(Blip1)in.readObject(); </span></p>

<p><span>// OOPS! Throws
an exception: </span></p>

<p><span>//! print(&quot;Recovering
b2:&quot;); </span></p>

<p><span>//! b2 =
(Blip2)in.readObject(); </span></p>

<p><span>} </span></p>

<p><span>} /* Output: </span></p>

<p><span>Constructing
objects: </span></p>

<p><span>Blip1
Constructor </span></p>

<p><span>Blip2
Constructor </span></p>

<p><span>Saving objects: </span></p>

<p><span>Blip1.writeExternal
</span></p>

<p><span>Blip2.writeExternal
</span></p>

<p><span>Recovering b1: </span></p>

<p><span>Blip1
Constructor </span></p>

<p><span>Blip1.readExternal
</span></p>

<p><span>*///:~ </span></p>

<p><span>The reason that the <b>Blip2
</b>object is not recovered is that trying to do so causes an exception. Can
you see the difference between <b>Blip1 </b>and <b>Blip2</b>? The constructor
for <b>Blip1 </b>is <b>public</b>, while the constructor for <b>Blip2 </b>is
not, and that causes the exception upon recovery. Try making <b>Blip2</b>'s
constructor <b>public </b>and removing the //! comments to see the correct
results. </span></p>

<p><span>When <b>b1 </b>is
recovered, the <b>Blip1 </b>default constructor is called. This is different
from recovering a <b>Serializable </b>object, in which the object is
constructed entirely from its stored bits, with no constructor calls. With an <b>Externalizable
</b>object, all the normal default construction behavior occurs (including the
initializations at the point of field definition), and <i>then </i><b>readExternal(
) </b>is called. You need to be aware of thisin particular, the fact that all
the default construction always takes placeto produce the correct behavior in
your <b>Externalizable </b>objects. </span></p>

<p><span>Here's an example that
shows what you must do to fully store and retrieve an <b>Externalizable </b>object:
</span></p>

<p><span>//:
io/Blip3.java </span></p>

<p><span>//
Reconstructing an externalizable object. </span></p>

<p><span>import
java.io.*; </span></p>

<p><span>import static
net.mindview.util.Print.*; </span></p>

<p><span>public class
Blip3 implements Externalizable { </span></p>

<p><span>private int i; </span></p>

<p><span>private String
s; // No initialization </span></p>

<p><span>public Blip3() {
</span></p>

<p><span>print(&quot;Blip3
Constructor&quot;); </span></p>

<p><span>// s, i not
initialized </span></p>

<p><span>} </span></p>

<p><span>public
Blip3(String x, int a) { </span></p>

<p><span>print(&quot;Blip3(String
x, int a)&quot;); </span></p>

<p><span>s = x; </span></p>

<p><span>i = a; </span></p>

<p><span>// s &amp; i
initialized only in non-default constructor. </span></p>

<p><span>} </span></p>

<p><span>public String
toString() { return s + i; } </span></p>

<p><span>public void
writeExternal(ObjectOutput out) </span></p>

<p><span>throws
IOException { </span></p>

<p><i><span>708
Thinking in Java Bruce Eckel </span></i></p>

<p><span>print(&quot;Blip3.writeExternal&quot;);
</span></p>

<p><span>// You must do
this: </span></p>

<p><span>out.writeObject(s);
</span></p>

<p><span>out.writeInt(i);
</span></p>

<p><span>} </span></p>

<p><span>public void
readExternal(ObjectInput in) </span></p>

<p><span>throws
IOException, ClassNotFoundException { </span></p>

<p><span>print(&quot;Blip3.readExternal&quot;);
</span></p>

<p><span>// You must do
this: </span></p>

<p><span>s =
(String)in.readObject(); </span></p>

<p><span>i =
in.readInt(); </span></p>

<p><span>} </span></p>

<p><span>public static
void main(String[] args) </span></p>

<p><span>throws
IOException, ClassNotFoundException { </span></p>

<p><span>print(&quot;Constructing
objects:&quot;); </span></p>

<p><span>Blip3 b3 = new
Blip3(&quot;A String &quot;, 47); </span></p>

<p><span>print(b3); </span></p>

<p><span>ObjectOutputStream
o = new ObjectOutputStream( </span></p>

<p><span>new
FileOutputStream(&quot;Blip3.out&quot;)); </span></p>

<p><span>print(&quot;Saving
object:&quot;); </span></p>

<p><span>o.writeObject(b3);
</span></p>

<p><span>o.close(); </span></p>

<p><span>// Now get it
back: </span></p>

<p><span>ObjectInputStream
in = new ObjectInputStream( </span></p>

<p><span>new
FileInputStream(&quot;Blip3.out&quot;)); </span></p>

<p><span>print(&quot;Recovering
b3:&quot;); </span></p>

<p><span>b3 =
(Blip3)in.readObject(); </span></p>

<p><span>print(b3); </span></p>

<p><span>} </span></p>

<p><span>} /* Output: </span></p>

<p><span>Constructing
objects: </span></p>

<p><span>Blip3(String x,
int a) </span></p>

<p><span>A String 47 </span></p>

<p><span>Saving object: </span></p>

<p><span>Blip3.writeExternal
</span></p>

<p><span>Recovering b3: </span></p>

<p><span>Blip3
Constructor </span></p>

<p><span>Blip3.readExternal
</span></p>

<p><span>A String 47 </span></p>

<p><span>*///:~ </span></p>

<p><span>The fields s and i are
initialized only in the second constructor, but not in the default constructor.
This means that if you don't initialize <b>s </b>and <b>i </b>in <b>readExternal(
)</b>, <b>s </b>will be <b>null </b>and <b>i </b>will be zero (since the storage
for the object gets wiped to zero in the first step of object creation). If you
comment out the two lines of code following the phrases &quot;You must do
this:&quot; and run the program, you'll see that when the object is recovered, <b>s
</b>is <b>null </b>and <b>i </b>is zero. </span></p>

<p><span>If you are inheriting from
an <b>Externalizable </b>object, you'll typically call the base-class versions
of <b>writeExternal( ) </b>and <b>readExternal( ) </b>to provide proper storage
and retrieval of the base-class components. </span></p>

<p><span>So to make things work
correctly, you must not only write the important data from the object during
the <b>writeExternal( ) </b>method (there is no default behavior that writes
any of the member objects for an <b>Externalizable </b>object), but you must
also recover that data in the <b>readExternal( ) </b>method. This can be a bit
confusing at first because the default construction behavior for an <b>Externalizable
</b>object can make it seem like some kind of storage and retrieval takes place
automatically. It does not. </span></p>

<p><b><span>Exercise 28 : </span></b><span>(2) <b>In Blips.java</b>,
copy the file and rename it to <b>BlipCheck.java </b>and rename the class <b>Blip2
</b>to <b>BlipCheck </b>(making it <b>public </b>and removing the public scope
from the class <b>Blips </b>in the process). Remove the //! marks in the file
and execute the </span></p>

<p><i><span>I/O
709 </span></i></p>

<p><span>program,
including the offending lines. Next, comment out the default constructor for <b>BlipCheck</b>.
Run it and explain why it works. Note that after compiling, you must execute
the program with &quot;<b>Java Blips</b>&quot; because the <b>main( ) </b>method
is still in the class <b>Blips</b>. </span></p>

<p><b><span>Exercise 29: </span></b><span>(2) In <b>Blip3.java</b>,
comment out the two lines after the phrases &quot;You must do this:&quot; and
run the program. Explain the result and why it differs from when the two lines
are in the program.</span></p>

<p><span>The <b>transient
</b>keyword </span></p>

<p><span>When you're
controlling serialization, there might be a particular subobject that you don't
want Java's serialization mechanism to automatically save and restore. This is
commonly the case if that subobject represents sensitive information that you
don't want to serialize, such as a password. Even if that information is <b>private
</b>in the object, once it has been serialized, it's possible for someone to
access it by reading a file or intercepting a network transmission. </span></p>

<p><span>One way to
prevent sensitive parts of your object from being serialized is to implement
your class as <b>Externalizable</b>, as shown previously. Then nothing is
automatically serialized, and you can explicitly serialize only the necessary
parts inside <b>writeExternal( )</b>. </span></p>

<p><span>If you're
working with a <b>Serializable </b>object, however, all serialization happens
automatically. To control this, you can turn off serialization on a
field-by-field basis using the <b>transient </b>keyword, which says,
&quot;Don't bother saving or restoring thisI'll take care of it.&quot; </span></p>

<p><span>For example,
consider a <b>Logon </b>object that keeps information about a particular login
session. Suppose that, once you verify the login, you want to store the data,
but without the password. The easiest way to do this is by implementing <b>Serializable
</b>and marking the <b>password </b>field as <b>transient</b>. Here's what it
looks like: </span></p>

<p><span>//:
io/Logon.java </span></p>

<p><span>//
Demonstrates the &quot;transient&quot; keyword. </span></p>

<p><span>import
java.util.concurrent.*; </span></p>

<p><span>import
java.io.*; </span></p>

<p><span>import
java.util.*; </span></p>

<p><span>import
static net.mindview.util.Print.*; </span></p>

<p><span>public
class Logon implements Serializable { </span></p>

<p><span>private
Date date = new Date(); </span></p>

<p><span>private
String username; </span></p>

<p><span>private
transient String password; </span></p>

<p><span>public
Logon(String name, String pwd) { </span></p>

<p><span>username
= name; </span></p>

<p><span>password
= pwd; </span></p>

<p><span>} </span></p>

<p><span>public
String toString() { </span></p>

<p><span>return
&quot;logon info: \n username: &quot; + username + </span></p>

<p><span>&quot;\n
date: &quot; + date + &quot;\n password: &quot; + password; </span></p>

<p><span>} </span></p>

<p><span>public
static void main(String[] args) throws Exception { </span></p>

<p><span>Logon
a = new Logon(&quot;Hulk&quot;, &quot;myLittlePony&quot;); </span></p>

<p><span>print(&quot;logon
a = &quot; + a); </span></p>

<p><span>ObjectOutputStream
o = new ObjectOutputStream( </span></p>

<p><span>new
FileOutputStream(&quot;Logon.out&quot;)); </span></p>

<p><span>o.writeObject(a);
</span></p>

<p><span>o.close();
</span></p>

<p><span>TimeUnit.SECONDS.sleep(1);
// Delay </span></p>

<p><span>//
Now get them back: </span></p>

<p><span>ObjectInputStream
in = new ObjectInputStream( </span></p>

<p><span>new
FileInputStream(&quot;Logon.out&quot;)); </span></p>

<p><i><span>710
Thinking in Java Bruce Eckel </span></i></p>

<p><span>print(&quot;Recovering
object at &quot; + new Date()); </span></p>

<p><span>a =
(Logon)in.readObject(); </span></p>

<p><span>print(&quot;logon
a = &quot; + a); </span></p>

<p><span>} </span></p>

<p><span>} /* Output:
(Sample) </span></p>

<p><span>logon a = logon
info: </span></p>

<p><span>username: Hulk </span></p>

<p><span>date: Sat Nov 19
15:03:26 MST 2005 </span></p>

<p><span>password:
myLittlePony </span></p>

<p><span>Recovering
object at Sat Nov 19 15:03:28 MST 2005 </span></p>

<p><span>logon a = logon
info: </span></p>

<p><span>username: Hulk </span></p>

<p><span>date: Sat Nov 19
15:03:26 MST 2005 </span></p>

<p><span>password: null </span></p>

<p><span>*///:~ </span></p>

<p><span>You can see that the <b>date
</b>and <b>username </b>fields are ordinary (not <b>transient</b>), and thus
are automatically serialized. However, the <b>password </b>is <b>transient</b>,
so it is not stored to disk; also, the serialization mechanism makes no attempt
to recover it. When the object is recovered, the <b>password </b>field is <b>null</b>.
Note that while <b>toString( ) </b>assembles a <b>String </b>object using the
overloaded'+' operator, a <b>null </b>reference is automatically converted to
the string &quot;null.&quot; </span></p>

<p><span>You can also see that the <b>date
</b>field is stored to and recovered from disk and not generated anew. </span></p>

<p><span>Since <b>Externalizable </b>objects
do not store any of their fields by default, the <b>transient </b>keyword is
for use with <b>Serializable </b>objects only. </span></p>

<p><span>An alternative to <b>Externalizable
</b></span></p>

<p><span>If you're not keen on
implementing the <b>Externalizable </b>interface, there's another approach. You
can implement the <b>Serializable </b>interface and <i>add </i>(notice I say
&quot;add&quot; and not &quot;override&quot; or &quot;implement&quot;) methods
called <b>writeObject( ) </b>and <b>readObject( ) </b>that will automatically
be called when the object is serialized and deserialized, respectively. That
is, if you provide these two methods, they will be used instead of the default
serialization. </span></p>

<p><span>The methods must have
these exact signatures: </span></p>

<p><span>private void
writeObject(ObjectOutputStream stream) </span></p>

<p><span>throws
IOException; </span></p>

<p><span>private void
readObject(ObjectlnputStream stream) </span></p>

<p><span>throws
IOException, ClassNotFoundException </span></p>

<p><span>From a design standpoint,
things get really weird here. First of all, you might think that because these
methods are not part of a base class or the <b>Serializable </b>interface, they
ought to be defined in their own interface(s). But notice that they are defined
as <b>private</b>, which means they are to be called only by other members of
this class. However, you don't actually call them from other members of this
class, but instead the <b>writeObject( ) </b>and <b>readObject( ) </b>methods
of the <b>ObjectOutputStream </b>and <b>ObjectInputStream </b>objects call your
object's <b>writeObject( ) </b>and <b>readObject( ) </b>methods. (Notice my tremendous
restraint in not launching into a long diatribe about using the same method
names here. In a word: confusing.) You might wonder how the <b>ObjectOutputStream
</b>and </span></p>

<p><i><span>I/O
711 712 Thinking in Java Bruce Eckel </span></i></p>

<p><sup><span>6 </span></sup><span>The section
&quot;Interfaces and type information&quot; at the end of the <i>Type
Information </i>chapter shows how it's possible to access <b>private </b>methods
from outside of the class.</span></p>

<p><span>&nbsp;</span></p>

<p><b><span>ObjectInputStream </span></b><span>objects have access to <b>private
</b>methods of your class. We can only assume that this is part of the
serialization magic.</span><span>6
</span></p>

<p><span>Anything defined in an
interface is automatically <b>public</b>, so if <b>writeObject( ) </b>and <b>readObject(
) </b>must be <b>private</b>, then they can't be part of an interface. Since
you must follow the signatures exactly, the effect is the same as if you're
implementing an interface. </span></p>

<p><span>It would appear that when
you call <b>ObjectOutputStream.writeObject( )</b>, the <b>Serializable </b>object
that you pass it to is interrogated (using reflection, no doubt) to see if it
implements its own <b>writeObject( )</b>. If so, the normal serialization
process is skipped and the custom <b>writeObject( ) </b>is called. The same
situation exists for <b>readObject( )</b>. </span></p>

<p><span>There's one other twist.
Inside your <b>writeObject( )</b>, you can choose to perform the default <b>writeObject(
) </b>action by calling <b>defaultWriteObject( )</b>. Likewise, inside <b>readObject(
) </b>you can call <b>defaultReadObject( )</b>. Here is a simple example that
demonstrates how you can control the storage and retrieval of a <b>Serializable
</b>object: </span></p>

<p><span>//:
io/SerialCtl.java </span></p>

<p><span>// Controlling
serialization by adding your own </span></p>

<p><span>// writeObject()
and readObject() methods. </span></p>

<p><span>import
java.io.*; </span></p>

<p><span>public class
SerialCtl implements Serializable { </span></p>

<p><span>private String
a; </span></p>

<p><span>private
transient String b; </span></p>

<p><span>public
SerialCtl(String aa, String bb) { </span></p>

<p><span>a = &quot;Not
Transient: &quot; + aa; </span></p>

<p><span>b =
&quot;Transient: &quot; + bb; </span></p>

<p><span>} </span></p>

<p><span>public String
toString() { return a + &quot;\n&quot; + b; } </span></p>

<p><span>private void
writeObject(ObjectOutputStream stream) </span></p>

<p><span>throws
IOException { </span></p>

<p><span>stream.defaultWriteObject();
</span></p>

<p><span>stream.writeObject(b);
</span></p>

<p><span>} </span></p>

<p><span>private void
readObject(ObjectInputStream stream) </span></p>

<p><span>throws
IOException, ClassNotFoundException { </span></p>

<p><span>stream.defaultReadObject();
</span></p>

<p><span>b =
(String)stream.readObject(); </span></p>

<p><span>} </span></p>

<p><span>public static
void main(String[] args) </span></p>

<p><span>throws
IOException, ClassNotFoundException { </span></p>

<p><span>SerialCtl sc =
new SerialCtl(&quot;Test1&quot;, &quot;Test2&quot;); </span></p>

<p><span>System.out.println(&quot;Before:\n&quot;
+ sc); </span></p>

<p><span>ByteArrayOutputStream
buf= new ByteArrayOutputStream(); </span></p>

<p><span>ObjectOutputStream
o = new ObjectOutputStream(buf); </span></p>

<p><span>o.writeObject(sc);
</span></p>

<p><span>// Now get it
back: </span></p>

<p><span>ObjectInputStream
in = new ObjectInputStream( </span></p>

<p><span>new
ByteArrayInputStream(buf.toByteArray())); </span></p>

<p><span>SerialCtl sc2 =
(SerialCtl)in.readObject(); </span></p>

<p><span>System.out.println(&quot;After:\n&quot;
+ sc2); </span></p>

<p><span>} </span></p>

<p><span>} /* Output: </span></p>

<p><span>Before: </span></p>

<p><span>Not Transient:
Test1 </span></p>

<p><span>Transient: Test2
</span></p>

<p><span>After: </span></p>

<p><span>Not
Transient: Test1 </span></p>

<p><span>Transient: Test2
</span></p>

<p><span>*///:~ </span></p>

<p><span>In this example, one <b>String
</b>field is ordinary and the other is <b>transient</b>, to prove that the non-<b>transient
</b>field is saved by the <b>defaultWriteObject( ) </b>method and the <b>transient
</b>field is saved and restored explicitly. The fields are initialized inside
the constructor rather than at the point of definition to prove that they are
not being initialized by some automatic mechanism during deserialization. </span></p>

<p><span>If you use the default
mechanism to write the non-<b>transient </b>parts of your object, you must call
<b>defaultWriteObject( ) </b>as the first operation in <b>writeObject( )</b>, and
<b>defaultReadObject( ) </b>as the first operation in <b>readObject( )</b>.
These are strange method calls. It would appear, for example, that you are
calling <b>defaultWriteObject( ) </b>for an <b>ObjectOutputStream </b>and
passing it no arguments, and yet it somehow turns around and knows the
reference to your object and how to write all the non-<b>transient </b>parts.
Spooky. </span></p>

<p><span>The storage and retrieval
of the <b>transient </b>objects uses more familiar code. And yet, think about
what happens here. In <b>main( )</b>, a <b>SerialCtl </b>object is created, and
then it's serialized to an <b>ObjectOutputStream</b>. (Notice in this case that
a buffer is used instead of a fileit's all the same to the <b>ObjectOutputStream</b>.)
The serialization occurs in the line: </span></p>

<p><span>o.writeObject(sc);
</span></p>

<p><span>The <b>writeObject( ) </b>method
must be examining <b>sc </b>to see if it has its own <b>writeObject( ) </b>method.
(Not by checking the interfacethere isn't oneor the class type, but by
actually hunting for the method using reflection.) If it does, it uses that. A
similar approach holds true for <b>readObject( )</b>. Perhaps this was the only
practical way that they could solve the problem, but it's certainly strange. </span></p>

<p><span>Versioning </span></p>

<p><span>It's possible that you
might want to change the version of a serializable class (objects of the
original class might be stored in a database, for example). This is supported,
but you'll probably do it only in special cases, and it requires an extra depth
of understanding that we will not attempt to achieve here. The JDK documents
downloadable from <i>http://java.sun.com </i>cover this topic quite thoroughly.
</span></p>

<p><span>You will also notice in
the JDK documentation many comments that begin with: </span></p>

<p><b><i><span>Warning: </span></i></b><i><span>Serialized objects of this
class will not be compatible with future Swing releases</span></i><span>. <i>The current
serialization support is appropriate for short term storage or RMI between
applications ..</i>. </span></p>

<p><span>This is because the
versioning mechanism is too simple to work reliably in all situations,
especially with JavaBeans. They're working on a correction for the design, and
that's what the warning is about. </span></p>

<p><span>Using persistence </span></p>

<p><span>It's quite appealing to
use serialization technology to store some of the state of your program so that
you can easily restore the program to the current state later. But before you
can do this, some questions must be answered. What happens if you serialize two
objects that both have a reference to a third object? When you restore those
two objects from their serialized state, do you get only one occurrence of the
third object? What if you serialize your two objects to separate files and
deserialize them in different parts of your code? </span></p>

<p><i><span>I/O
713 </span></i></p>

<p><span>Here's an
example that shows the problem: </span></p>

<p><span>//:
io/MyWorld.java </span></p>

<p><span>import
java.io.*; </span></p>

<p><span>import
java.util.*; </span></p>

<p><span>import static
net.mindview.util.Print.*; </span></p>

<p><span>class House
implements Serializable {} </span></p>

<p><span>class Animal
implements Serializable { </span></p>

<p><span>private String
name; </span></p>

<p><span>private House
preferredHouse; </span></p>

<p><span>Animal(String
nm, House h) { </span></p>

<p><span>name = nm; </span></p>

<p><span>preferredHouse =
h; </span></p>

<p><span>} </span></p>

<p><span>public String
toString() { </span></p>

<p><span>return name +
&quot;[&quot; + super.toString() + </span></p>

<p><span>&quot;], &quot;
+ preferredHouse + &quot;\n&quot;; </span></p>

<p><span>} </span></p>

<p><span>} </span></p>

<p><span>public class
MyWorld { </span></p>

<p><span>public static
void main(String[] args) </span></p>

<p><span>throws
IOException, ClassNotFoundException { </span></p>

<p><span>House house =
new House(); </span></p>

<p><span>List&lt;Animal&gt;
animals = new ArrayList&lt;Animal&gt;(); </span></p>

<p><span>animals.add(new
Animal(&quot;Bosco the dog&quot;, house)); </span></p>

<p><span>animals.add(new
Animal(&quot;Ralph the hamster&quot;, house)); </span></p>

<p><span>animals.add(new
Animal(&quot;Molly the cat&quot;, house)); </span></p>

<p><span>print(&quot;animals:
&quot; + animals); </span></p>

<p><span>ByteArrayOutputStream
buf1 = </span></p>

<p><span>new
ByteArrayOutputStream(); </span></p>

<p><span>ObjectOutputStream
o1 = new ObjectOutputStream(buf1); </span></p>

<p><span>o1.writeObject(animals);
</span></p>

<p><span>o1.writeObject(animals);
// Write a 2nd set </span></p>

<p><span>// Write to a
different stream: </span></p>

<p><span>ByteArrayOutputStream
buf2 = </span></p>

<p><span>new
ByteArrayOutputStream(); </span></p>

<p><span>ObjectOutputStream
o2 = new ObjectOutputStream(buf2); </span></p>

<p><span>o2.writeObject(animals);
</span></p>

<p><span>// Now get them
back: </span></p>

<p><span>ObjectInputStream
in1 = new ObjectInputStream( </span></p>

<p><span>new
ByteArrayInputStream(buf1.toByteArray())); </span></p>

<p><span>ObjectInputStream
in2 = new ObjectInputStream( </span></p>

<p><span>new
ByteArrayInputStream(buf2.toByteArray())); </span></p>

<p><span>List </span></p>

<p><span>animals1 =
(List)in1.readObject(), </span></p>

<p><span>animals2 =
(List)in1.readObject(), </span></p>

<p><span>animals3 =
(List)in2.readObject(); </span></p>

<p><span>print(&quot;animals1:
&quot; + animals1); </span></p>

<p><span>print(&quot;animals2:
&quot; + animals2); </span></p>

<p><span>print(&quot;animals3:
&quot; + animals3); </span></p>

<p><span>} </span></p>

<p><span>} /* Output:
(Sample) </span></p>

<p><span>animals: [Bosco
the dog[Animal@addbf1], House@42e816 </span></p>

<p><span>, Ralph the
hamster[Animal@9304b1], House@42e816 </span></p>

<p><span>, Molly the
cat[Animal@190d11], House@42e816 </span></p>

<p><span>] </span></p>

<p><span>animals1: [Bosco
the dog[Animal@de6f34], House@156ee8e </span></p>

<p><span>, Ralph the
hamster[Animal@47b480], House@156ee8e </span></p>

<p><span>, Molly the
cat[Animal@19b49e6], House@156ee8e </span></p>

<p><span>] </span></p>

<p><i><span>714
Thinking in Java Bruce Eckel </span></i></p>

<p><span>animals2:
[Bosco the dog[Animal@de6f34], House@156ee8e </span></p>

<p><span>, Ralph the
hamster[Animal@47b480], House@156ee8e </span></p>

<p><span>, Molly the
cat[Animal@19b49e6], House@156ee8e </span></p>

<p><span>] </span></p>

<p><span>animals3: [Bosco
the dog[Animal@10d448], House@e0e1c6 </span></p>

<p><span>, Ralph the
hamster[Animal@6ca1c], House@e0e1c6 </span></p>

<p><span>, Molly the
cat[Animal@1bf216a], House@e0e1c6 </span></p>

<p><span>] </span></p>

<p><span>*///:~ </span></p>

<p><span>One thing that's
interesting here is that it's possible to use object serialization to and from
a <b>byte </b>array as a way of doing a &quot;deep copy&quot; of any object
that's <b>Serializable</b>. (A deep copy means that you're duplicating the
entire web of objects, rather than just the basic object and its references.)
Object copying is covered in depth in the online supplements for this book. </span></p>

<p><b><span>Animal </span></b><span>objects contain fields of
type <b>House</b>. <b>In main( )</b>, a <b>List </b>of these <b>Animal</b>s is
created and it is serialized twice to one stream and then again to a separate
stream. When these are deserialized and printed, you see the output shown for
one run (the objects will be in different memory locations each run). </span></p>

<p><span>Of course, you expect that
the deserialized objects have different addresses from their originals. But
notice that in <b>animals1 </b>and <b>animals2</b>, the same addresses appear,
including the references to the <b>House </b>object that both share. On the
other hand, when <b>animals3 </b>is recovered, the system has no way of knowing
that the objects in this other stream are aliases of the objects in the first
stream, so it makes a completely different web of objects. </span></p>

<p><span>As long as you're
serializing everything to a single stream, you'll recover the same web of
objects that you wrote, with no accidental duplication of objects. Of course,
you can change the state of your objects in between the time you write the
first and the last, but that's your responsibility; the objects will be written
in whatever state they are in (and with whatever connections they have to other
objects) at the time you serialize them. </span></p>

<p><span>The safest thing to do if
you want to save the state of a system is to serialize as an &quot;atomic&quot;
operation. If you serialize some things, do some other work, and serialize some
more, etc., then you will not be storing the system safely. Instead, put all
the objects that comprise the state of your system in a single container and
simply write that container out in one operation. Then you can restore it with
a single method call as well. </span></p>

<p><span>The following example is
an imaginary computer-aided design (CAD) system that demonstrates the approach.
In addition, it throws in the issue of <b>static </b>fields; if you look at the
JDK documentation, you'll see that <b>Class </b>is <b>Serializable</b>, so it
should be easy to store the <b>static </b>fields by simply serializing the <b>Class
</b>object. That seems like a sensible approach, anyway. </span></p>

<p><span>//:
io/StoreCADState.java </span></p>

<p><span>// Saving the
state of a pretend CAD system. </span></p>

<p><span>import
java.io.*; </span></p>

<p><span>import
java.util.*; </span></p>

<p><span>abstract class
Shape implements Serializable { </span></p>

<p><span>public static
final int RED = 1, BLUE = 2, GREEN = 3; </span></p>

<p><span>private int
xPos, yPos, dimension; </span></p>

<p><span>private static
Random rand = new Random(47); </span></p>

<p><span>private static
int counter = 0; </span></p>

<p><span>public abstract
void setColor(int newColor); </span></p>

<p><span>public abstract
int getColor(); </span></p>

<p><span>public Shape(int
xVal, int yVal, int dim) { </span></p>

<p><span>xPos = xVal; </span></p>

<p><span>yPos = yVal; </span></p>

<p><span>dimension = dim;
</span></p>

<p><i><span>I/O
715 </span></i></p>

<p><span>}
</span></p>

<p><span>public String
toString() { </span></p>

<p><span>return
getClass() + </span></p>

<p><span>&quot;color[&quot;
+ getColor() + &quot;] xPos[&quot; + xPos + </span></p>

<p><span>&quot;]
yPos[&quot; + yPos + &quot;] dim[&quot; + dimension + &quot;]\n&quot;; </span></p>

<p><span>} </span></p>

<p><span>public static
Shape randomFactory() { </span></p>

<p><span>int xVal =
rand.nextInt(100); </span></p>

<p><span>int yVal =
rand.nextInt(100); </span></p>

<p><span>int dim =
rand.nextInt(100); </span></p>

<p><span>switch(counter++
% 3) { </span></p>

<p><span>default: </span></p>

<p><span>case 0: return
new Circle(xVal, yVal, dim); </span></p>

<p><span>case 1: return
new Square(xVal, yVal, dim); </span></p>

<p><span>case 2: return
new Line(xVal, yVal, dim); </span></p>

<p><span>} </span></p>

<p><span>} </span></p>

<p><span>} </span></p>

<p><span>class Circle
extends Shape { </span></p>

<p><span>private static
int color = RED; </span></p>

<p><span>public
Circle(int xVal, int yVal, int dim) { </span></p>

<p><span>super(xVal,
yVal, dim); </span></p>

<p><span>} </span></p>

<p><span>public void
setColor(int newColor) { color = newColor; } </span></p>

<p><span>public int
getColor() { return color; } </span></p>

<p><span>} </span></p>

<p><span>class Square
extends Shape { </span></p>

<p><span>private static
int color; </span></p>

<p><span>public
Square(int xVal, int yVal, int dim) { </span></p>

<p><span>super(xVal,
yVal, dim); </span></p>

<p><span>color = RED; </span></p>

<p><span>} </span></p>

<p><span>public void
setColor(int newColor) { color = newColor; } </span></p>

<p><span>public int
getColor() { return color; } </span></p>

<p><span>} </span></p>

<p><span>class Line
extends Shape { </span></p>

<p><span>private static
int color = RED; </span></p>

<p><span>public static
void </span></p>

<p><span>serializeStaticState(ObjectOutputStream
os) </span></p>

<p><span>throws
IOException { os.writeInt(color); } </span></p>

<p><span>public static
void </span></p>

<p><span>deserializeStaticState(ObjectInputStream
os) </span></p>

<p><span>throws
IOException { color = os.readInt(); } </span></p>

<p><span>public Line(int
xVal, int yVal, int dim) { </span></p>

<p><span>super(xVal,
yVal, dim); </span></p>

<p><span>} </span></p>

<p><span>public void
setColor(int newColor) { color = newColor; } </span></p>

<p><span>public int
getColor() { return color; } </span></p>

<p><span>} </span></p>

<p><span>public class
StoreCADState { </span></p>

<p><span>public static
void main(String[] args) throws Exception { </span></p>

<p><span>List&lt;Class&lt;?
extends Shape&gt;&gt; shapeTypes = </span></p>

<p><span>new
ArrayList&lt;Class&lt;? extends Shape&gt;&gt;(); </span></p>

<p><span>// Add
references to the class objects: </span></p>

<p><span>shapeTypes.add(Circle.class);
</span></p>

<p><span>shapeTypes.add(Square.class);
</span></p>

<p><span>shapeTypes.add(Line.class);
</span></p>

<p><span>List&lt;Shape&gt;
shapes = new ArrayList&lt;Shape&gt;(); </span></p>

<p><span>// Make some
shapes: </span></p>

<p><i><span>716
Thinking in Java Bruce Eckel </span></i></p>

<p><span>for(int
i = 0; i &lt; 10; i++) </span></p>

<p><span>shapes.add(Shape.randomFactory());
</span></p>

<p><span>// Set all the
static colors to GREEN: </span></p>

<p><span>for(int i = 0; i
&lt; 10; i++) </span></p>

<p><span>((Shape)shapes.get(i)).setColor(Shape.GREEN);
</span></p>

<p><span>// Save the
state vector: </span></p>

<p><span>ObjectOutputStream
out = new ObjectOutputStream( </span></p>

<p><span>new
FileOutputStream(&quot;CADState.out&quot;)); </span></p>

<p><span>out.writeObject(shapeTypes);
</span></p>

<p><span>Line.serializeStaticState(out);
</span></p>

<p><span>out.writeObject(shapes);
</span></p>

<p><span>// Display the
shapes: </span></p>

<p><span>System.out.println(shapes);
</span></p>

<p><span>} </span></p>

<p><span>} /* Output: </span></p>

<p><span>[class
Circlecolor[3] xPos[58] yPos[55] dim[93] </span></p>

<p><span>, class
Squarecolor[3] xPos[61] yPos[61] dim[29] </span></p>

<p><span>, class
Linecolor[3] xPos[68] yPos[0] dim[22] </span></p>

<p><span>, class
Circlecolor[3] xPos[7] yPos[88] dim[28] </span></p>

<p><span>, class
Squarecolor[3] xPos[51] yPos[89] dim[9] </span></p>

<p><span>, class
Linecolor[3] xPos[78] yPos[98] dim[61] </span></p>

<p><span>, class
Circlecolor[3] xPos[20] yPos[58] dim[16] </span></p>

<p><span>, class
Squarecolor[3] xPos[40] yPos[11] dim[22] </span></p>

<p><span>, class
Linecolor[3] xPos[4] yPos[83] dim[6] </span></p>

<p><span>, class
Circlecolor[3] xPos[75] yPos[10] dim[42] </span></p>

<p><span>] </span></p>

<p><span>*///:~ </span></p>

<p><span>The <b>Shape </b>class <b>implements
Serializable</b>, so anything that is inherited from <b>Shape </b>is
automatically <b>Serializable </b>as well. Each <b>Shape </b>contains data, and
each derived <b>Shape </b>class contains a <b>static </b>field that determines
the color of all of those types of <b>Shape</b>s. (Placing a <b>static </b>field
in the base class would result in only one field, since <b>static </b>fields
are not duplicated in derived classes.) Methods in the base class can be
overridden to set the color for the various types (<b>static </b>methods are
not dynamically bound, so these are normal methods). The <b>randomFactory( ) </b>method
creates a different <b>Shape </b>each time you call it, using random values for
the <b>Shape </b>data. </span></p>

<p><b><span>Circle </span></b><span>and <b>Square </b>are
straightforward extensions of <b>Shape</b>; the only difference is that <b>Circle
</b>initializes <b>color </b>at the point of definition and <b>Square </b>initializes
it in the constructor. We'll leave the discussion of <b>Line </b>for later. </span></p>

<p><span>In <b>main( )</b>, one <b>ArrayList
</b>is used to hold the <b>Class </b>objects and the other to hold the shapes. </span></p>

<p><span>Recovering the objects is
fairly straightforward: </span></p>

<p><span>//:
io/RecoverCADState.java </span></p>

<p><span>// Restoring the
state of the pretend CAD system. </span></p>

<p><span>// {RunFirst:
StoreCADState} </span></p>

<p><span>import
java.io.*; </span></p>

<p><span>import
java.util.*; </span></p>

<p><span>public class
RecoverCADState { </span></p>

<p><span>@SuppressWarnings(&quot;unchecked&quot;)
</span></p>

<p><span>public static
void main(String[] args) throws Exception { </span></p>

<p><span>ObjectInputStream
in = new ObjectInputStream( </span></p>

<p><span>new
FileInputStream(&quot;CADState.out&quot;)); </span></p>

<p><span>// Read in the
same order they were written: </span></p>

<p><span>List&lt;Class&lt;?
extends Shape&gt;&gt; shapeTypes = </span></p>

<p><span>(List&lt;Class&lt;?
extends Shape&gt;&gt;)in.readObject(); </span></p>

<p><span>Line.deserializeStaticState(in);
</span></p>

<p><i><span>I/O
717 </span></i></p>

<p><span>List&lt;Shape&gt;
shapes = (List&lt;Shape&gt;)in.readObject(); </span></p>

<p><span>System.out.println(shapes);
</span></p>

<p><span>} </span></p>

<p><span>} /* Output: </span></p>

<p><span>[class
Circlecolor[1] xPos[58] yPos[55] dim[93] </span></p>

<p><span>, class
Squarecolor[0] xPos[61] yPos[61] dim[29] </span></p>

<p><span>, class
Linecolor[3] xPos[68] yPos[0] dim[22] </span></p>

<p><span>, class
Circlecolor[1] xPos[7] yPos[88] dim[28] </span></p>

<p><span>, class
Squarecolor[0] xPos[51] yPos[89] dim[9] </span></p>

<p><span>, class
Linecolor[3] xPos[78] yPos[98] dim[61] </span></p>

<p><span>, class
Circlecolor[1] xPos[20] yPos[58] dim[16] </span></p>

<p><span>, class
Squarecolor[0] xPos[40] yPos[11] dim[22] </span></p>

<p><span>, class
Linecolor[3] xPos[4] yPos[83] dim[6] </span></p>

<p><span>, class
Circlecolor[1] xPos[75] yPos[10] dim[42] </span></p>

<p><span>] </span></p>

<p><span>*///:~ </span></p>

<p><span>You can see that the
values of <b>xPos</b>, <b>yPos</b>, and <b>dim </b>were all stored and
recovered successfully, but there's something wrong with the retrieval of the <b>static
</b>information. It's all &quot;3&quot; going in, but it doesn't come out that
way. <b>Circles </b>have a value of 1 (<b>RED</b>, which is the definition),
and <b>Square</b>s have a value of 0 (remember, they are initialized in the
constructor). It's as if the <b>statics </b>didn't get serialized at all!
That's righteven though class <b>Class </b>is <b>Serializable</b>, it doesn't
do what you expect. So if you want to serialize <b>static</b>s, you must do it
yourself. </span></p>

<p><span>This is what the <b>serializeStaticState(
) </b>and <b>deserializeStaticState( ) static </b>methods in <b>Line </b>are
for. You can see that they are explicitly called as part of the storage and
retrieval process. (Note that the order of writing to the serialize file and
reading back from it must be maintained.) Thus to make these programs run
correctly, you must: </span></p>

<p><span>1.<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span>Add a <b>serializeStaticState(
) </b>and <b>deserializeStaticState( ) </b>to the shapes. </span></p>

<p><span>2.<span>&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>Remove the <b>ArrayList
shapeTypes </b>and all code related to it. </span></p>

<p><span>&nbsp;</span></p>

<p><span>1.<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>Add calls to the new
serialize and deserialize <b>static </b>methods in the shapes. </span></p>

<p><span>&nbsp;</span></p>

<p><span>Another issue you might
have to think about is security, since serialization also saves <b>private </b>data.
If you have a security issue, those fields should be marked as <b>transient</b>.
But then you have to design a secure way to store that information so that when
you do a restore, you can reset those <b>private </b>variables. </span></p>

<p><b><span>Exercise 30: </span></b><span>(1) Repair the program <b>CADState.java
</b>as described in the text. </span></p>

<p><span>XML </span></p>

<p><span>An important limitation of
object serialization is that it is a Java-only solution: Only Java programs can
deserialize such objects. A more interoperable solution is to convert data to
XML format, which allows it to be consumed by a large variety of platforms and
languages. </span></p>

<p><span>Because of its popularity,
there are a confusing number of options for programming with XML, including the
<b>javax.xml.* </b>libraries distributed with the JDK. I've chosen to use
Elliotte Rusty Harold's open-source XOM library (downloads and documentation at
<i>www.xom.nu) </i>because it seems to be the simplest and most straightforward
way to produce and modify XML using Java. In addition, XOM emphasizes XML
correctness. </span></p>

<p><span>As an example, suppose you
have <b>Person </b>objects containing first and last names that you'd like to
serialize into XML. The following <b>Person </b>class has a <b>getXML( ) </b>method
that uses </span></p>

<p><i><span>718
Thinking in Java Bruce Eckel </span></i></p>

<p><span>XOM to produce
the <b>Person </b>data converted to an XML <b>Element </b>object, and a
constructor that takes an <b>Element </b>and extracts the appropriate <b>Person
</b>data (notice that the XML examples are in their own subdirectory): </span></p>

<p><span>//:
xml/Person.java </span></p>

<p><span>// Use the XOM
library to write and read XML </span></p>

<p><span>// {Requires:
nu.xom.Node; You must install </span></p>

<p><span>// the XOM
library from http://www.xom.nu } </span></p>

<p><span>import nu.xom.*;
</span></p>

<p><span>import
java.io.*; </span></p>

<p><span>import
java.util.*; </span></p>

<p><span>public class
Person { </span></p>

<p><span>private String
first, last; </span></p>

<p><span>public
Person(String first, String last) { </span></p>

<p><span>this.first =
first; </span></p>

<p><span>this.last =
last; </span></p>

<p><span>} </span></p>

<p><span>// Produce an
XML Element from this Person object: </span></p>

<p><span>public Element
getXML() { </span></p>

<p><span>Element person =
new Element(&quot;person&quot;); </span></p>

<p><span>Element
firstName = new Element(&quot;first&quot;); </span></p>

<p><span>firstName.appendChild(first);
</span></p>

<p><span>Element lastName
= new Element(&quot;last&quot;); </span></p>

<p><span>lastName.appendChild(last);
</span></p>

<p><span>person.appendChild(firstName);
</span></p>

<p><span>person.appendChild(lastName);
</span></p>

<p><span>return person; </span></p>

<p><span>} </span></p>

<p><span>// Constructor
to restore a Person from an XML Element: </span></p>

<p><span>public
Person(Element person) { </span></p>

<p><span>first=
person.getFirstChildElement(&quot;first&quot;).getValue(); </span></p>

<p><span>last =
person.getFirstChildElement(&quot;last&quot;).getValue(); </span></p>

<p><span>} </span></p>

<p><span>public String
toString() { return first + &quot; &quot; + last; } </span></p>

<p><span>// Make it human-readable:
</span></p>

<p><span>public static
void </span></p>

<p><span>format(OutputStream
os, Document doc) throws Exception { </span></p>

<p><span>Serializer
serializer= new Serializer(os,&quot;ISO-8859-1&quot;); </span></p>

<p><span>serializer.setIndent(4);
</span></p>

<p><span>serializer.setMaxLength(60);
</span></p>

<p><span>serializer.write(doc);
</span></p>

<p><span>serializer.flush();
</span></p>

<p><span>} </span></p>

<p><span>public static
void main(String[] args) throws Exception { </span></p>

<p><span>List&lt;Person&gt;
people = Arrays.asList( </span></p>

<p><span>new
Person(&quot;Dr. Bunsen&quot;, &quot;Honeydew&quot;), </span></p>

<p><span>new
Person(&quot;Gonzo&quot;, &quot;The Great&quot;), </span></p>

<p><span>new
Person(&quot;Phillip J.&quot;, &quot;Fry&quot;)); </span></p>

<p><span>System.out.println(people);
</span></p>

<p><span>Element root =
new Element(&quot;people&quot;); </span></p>

<p><span>for(Person p :
people) </span></p>

<p><span>root.appendChild(p.getXML());
</span></p>

<p><span>Document doc =
new Document(root); </span></p>

<p><span>format(System.out,
doc); </span></p>

<p><span>format(new
BufferedOutputStream(new FileOutputStream( </span></p>

<p><span>&quot;People.xml&quot;)),
doc); </span></p>

<p><span>} </span></p>

<p><span>} /* Output: </span></p>

<p><span>[Dr. Bunsen
Honeydew, Gonzo The Great, Phillip J. Fry] </span></p>

<p><span>&lt;?xml
version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt; </span></p>

<p><span>&lt;people&gt; </span></p>

<p><span>&lt;person&gt; </span></p>

<p><i><span>I/O
719 </span></i></p>

<p><span>&lt;first&gt;Dr.
Bunsen&lt;/first&gt; </span></p>

<p><span>&lt;last&gt;Honeydew&lt;/last&gt;
</span></p>

<p><span>&lt;/person&gt; </span></p>

<p><span>&lt;person&gt; </span></p>

<p><span>&lt;first&gt;Gonzo&lt;/first&gt;
</span></p>

<p><span>&lt;last&gt;The
Great&lt;/last&gt; </span></p>

<p><span>&lt;/person&gt; </span></p>

<p><span>&lt;person&gt; </span></p>

<p><span>&lt;first&gt;Phillip
J.&lt;/first&gt; </span></p>

<p><span>&lt;last&gt;Fry&lt;/last&gt;
</span></p>

<p><span>&lt;/person&gt; </span></p>

<p><span>&lt;/people&gt; </span></p>

<p><span>*///:~ </span></p>

<p><span>The XOM methods are fairly
self-explanatory and can be found in the XOM documentation. XOM also contains a
<b>Serializer </b>class that you can see used in the <b>format( ) </b>method to
turn the XML into a more readable form. If you just call <b>toXML( ) </b>you'll
get everything run together, so the <b>Serializer </b>is a convenient tool. </span></p>

<p><span>Deserializing <b>Person </b>objects
from an XML file is also simple: </span></p>

<p><span>//:
xml/People.java </span></p>

<p><span>// {Requires:
nu.xom.Node; You must install </span></p>

<p><span>// the XOM
library from http://www.xom.nu } </span></p>

<p><span>// {RunFirst:
Person} </span></p>

<p><span>import nu.xom.*;
</span></p>

<p><span>import
java.util.*; </span></p>

<p><span>public class
People extends ArrayList&lt;Person&gt; { </span></p>

<p><span>public
People(String fileName) throws Exception { </span></p>

<p><span>Document doc =
new Builder().build(fileName); </span></p>

<p><span>Elements elements
= </span></p>

<p><span>doc.getRootElement().getChildElements();
</span></p>

<p><span>for(int i = 0; i
&lt; elements.size(); i++) </span></p>

<p><span>add(new
Person(elements.get(i))); </span></p>

<p><span>} </span></p>

<p><span>public static
void main(String[] args) throws Exception { </span></p>

<p><span>People p = new
People(&quot;People.xml&quot;); </span></p>

<p><span>System.out.println(p);
</span></p>

<p><span>} </span></p>

<p><span>} /* Output: </span></p>

<p><span>[Dr. Bunsen
Honeydew, Gonzo The Great, Phillip J. Fry] </span></p>

<p><span>*///:~ </span></p>

<p><span>The <b>People </b>constructor
opens and reads a file using XOM's <b>Builder.build( ) </b>method, and the <b>getChildElements(
) </b>method produces an <b>Elements </b>list (not a standard Java <b>List</b>,
but an object that only has a <b>size( ) </b>and <b>get( ) </b>methodHarold
did not want to force people to use Java SE5, but still wanted a type-safe
container). Each <b>Element </b>in this list represents a <b>Person </b>object,
so it is handed to the second <b>Person </b>constructor. Note that this
requires that you know ahead of time the exact structure of your XML file, but
this is often true with these kinds of problems. If the structure doesn't match
what you expect, XOM will throw an exception. It's also possible for you to
write more complex code that will explore the XML document rather than making
assumptions about it, for cases when you have less concrete information about
the incoming XML structure. </span></p>

<p><span>In order to get these
examples to compile, you will have to put the JAR files from the XOM
distribution into your classpath. </span></p>

<p><span>This has only been a brief
introduction to XML programming with Java and the XOM library; for more
information see <i>www.xom.nu</i>. </span></p>

<p><i><span>720
Thinking in Java Bruce Eckel </span></i></p>

<p><b><span>Exercise
31: </span></b><span>(2)
Add appropriate address information to <b>Person.java </b>and <b>People.java</b>.
</span></p>

<p><b><span>Exercise 32: </span></b><span>(4) Using a <b>Map&lt;String,Integer</b>&gt;
and the <b>net.mindview.util.TextFile </b>utility, write a program that counts
the occurrence of words in a file (use <b>&quot;\\W+&quot; </b>as the second
argument to the <b>TextFile </b>constructor). Store the results as an XML file.
</span></p>

<p><span>Preferences </span></p>

<p><span>The <i>Preferences </i>API
is much closer to persistence than it is to object serialization, because it
automatically stores and retrieves your information. However, its use is
restricted to small and limited data setsyou can only hold primitives and <b>Strings</b>,
and the length of each stored <b>String </b>can't be longer than 8K (not tiny,
but you don't want to build anything serious with it, either). As the name
suggests, the Preferences API is designed to store and retrieve user preferences
and program-configuration settings. </span></p>

<p><span>Preferences are key-value
sets (like <b>Map</b>s) stored in a hierarchy of nodes. Although the node
hierarchy can be used to create complicated structures, it's typical to create
a single node named after your class and store the information there. Here's a
simple example: </span></p>

<p><span>//:
io/PreferencesDemo.java </span></p>

<p><span>import
java.util.prefs.*; </span></p>

<p><span>import static
net.mindview.util.Print.*; </span></p>

<p><span>public class
PreferencesDemo { </span></p>

<p><span>public static
void main(String[] args) throws Exception { </span></p>

<p><span>Preferences
prefs = Preferences </span></p>

<p><span>.userNodeForPackage(PreferencesDemo.class);
</span></p>

<p><span>prefs.put(&quot;Location&quot;,
&quot;Oz&quot;); </span></p>

<p><span>prefs.put(&quot;Footwear&quot;,
&quot;Ruby Slippers&quot;); </span></p>

<p><span>prefs.putInt(&quot;Companions&quot;,
4); </span></p>

<p><span>prefs.putBoolean(&quot;Are
there witches?&quot;, true); </span></p>

<p><span>int usageCount =
prefs.getInt(&quot;UsageCount&quot;, 0); </span></p>

<p><span>usageCount++; </span></p>

<p><span>prefs.putInt(&quot;UsageCount&quot;,
usageCount); </span></p>

<p><span>for(String key :
prefs.keys()) </span></p>

<p><span>print(key +
&quot;: &quot;+ prefs.get(key, null)); </span></p>

<p><span>// You must
always provide a default value: </span></p>

<p><span>print(&quot;How
many companions does Dorothy have? &quot; + </span></p>

<p><span>prefs.getInt(&quot;Companions&quot;,
0)); </span></p>

<p><span>} </span></p>

<p><span>} /* Output:
(Sample) </span></p>

<p><span>Location: Oz </span></p>

<p><span>Footwear: Ruby
Slippers </span></p>

<p><span>Companions: 4 </span></p>

<p><span>Are there
witches?: true </span></p>

<p><span>UsageCount: 53 </span></p>

<p><span>How many
companions does Dorothy have? 4 </span></p>

<p><span>*///:~ </span></p>

<p><span>Here, <b>userNodeForPackage(
) </b>is used, but you could also choose <b>systemNodeForPackage( )</b>; the
choice is somewhat arbitrary, but the idea is that &quot;user&quot; is for
individual user preferences, and &quot;system&quot; is for general installation
configuration. Since <b>main( ) </b>is <b>static</b>, <b>PreferencesDemo.class </b>is
used to identify the node, but inside a non<b>static </b>method, you'll usually
use <b>getClass( )</b>. You don't need to use the current class as the node
identifier, but that's the usual practice. </span></p>

<p><i><span>I/O
721 </span></i></p>

<p><span>Once you
create the node, it's available for either loading or reading data. This
example loads the node with various types of items and then gets the <b>keys( )</b>.
These come back as a <b>String[]</b>, which you might not expect if you're used
to the <b>keys( ) </b>method in the collections library. Notice the second
argument to <b>get( )</b>. This is the default value that is produced if there
isn't any entry for that key value. While iterating through a set of keys, you
always know there's an entry, so using <b>null </b>as the default is safe, but
normally you'll be fetching a named key, as in: </span></p>

<p><span>prefs.getInt(&quot;Companions&quot;,
0)); </span></p>

<p><span>In the normal case, you'll
want to provide a reasonable default value. In fact, a typical idiom is seen in
the lines: </span></p>

<p><span>int usageCount =
prefs.getInt(&quot;UsageCount&quot;, 0); </span></p>

<p><span>usageCount++; </span></p>

<p><span>prefs.putInt(&quot;UsageCount&quot;,
usageCount); </span></p>

<p><span>This way, the first time
you run the program, the <b>UsageCount </b>will be zero, but on subsequent
invocations it will be nonzero. </span></p>

<p><span>When you run <b>PreferencesDemo.java
</b>you'll see that the <b>UsageCount </b>does indeed increment every time you
run the program, but where is the data stored? There's no local file that
appears after the program is run the first time. The Preferences API uses
appropriate system resources to accomplish its task, and these will vary
depending on the OS. In Windows, the registry is used (since it's already a
hierarchy of nodes with key-value pairs). But the whole point is that the
information is magically stored for you so that you don't have to worry about
how it works from one system to another. </span></p>

<p><span>There's more to the
Preferences API than shown here. Consult the JDK documentation, which is fairly
understandable, for further details. </span></p>

<p><b><span>Exercise 33: </span></b><span>(2) Write a program that
displays the current value of a directory called &quot;base directory&quot; and
prompts you for a new value. Use the Preferences API to store the value.</span></p>

<p><span>Summary </span></p>

<p><span>The Java I/O
stream library does satisfy the basic requirements: You can perform reading and
writing with the console, a file, a block of memory, or even across the
Internet. With inheritance, you can create new types of input and output
objects. And you can even add a simple extensibility to the kinds of objects a
stream will accept by redefining the <b>toString( ) </b>method that's
automatically called when you pass an object to a method that's expecting a <b>String
</b>(Java's limited &quot;automatic type conversion&quot;). </span></p>

<p><span>There are
questions left unanswered by the documentation and design of the I/O stream
library. For example, it would have been nice if you could say that you want an
exception thrown if you try to overwrite a file when opening it for outputsome
programming systems allow you to specify that you want to open an output file,
but only if it doesn't already exist. In Java, it appears that you are supposed
to use a <b>File </b>object to determine whether a file exists, because if you
open it as a <b>FileOutputStream </b>or <b>FileWriter</b>, it will always get
overwritten. </span></p>

<p><span>The I/O stream
library brings up mixed feelings; it does much of the job and it's portable.
But if you don't already understand the Decorator design pattern, the design is
not intuitive, so there's extra overhead in learning and teaching it. It's also
incomplete; for example, I shouldn't have to write utilities like <b>TextFile </b>(the
new Java SE5 <b>PrintWriter </b>is a step in the right direction here, but is
only a partial solution). There has been a big improvement in </span></p>

<p><i><span>722
Thinking in Java Bruce Eckel I/O 723 </span></i></p>

<p><span>Java SE5:
They've finally added the kind of output formatting that virtually every other
language has always supported. </span></p>

<p><span>Once you <i>do </i>understand
the Decorator pattern and begin using the library in situations that require
its flexibility, you can begin to benefit from this design, at which point its
cost in extra lines of code may not bother you as much. </span></p>

<p><span>Solutions to selected exercises can be found in the electronic
document <i>The Thinking in Java Annotated Solution Guide</i>, available for
sale from <i>www.MindView.net</i>.</span></p>
</body>

</html>
